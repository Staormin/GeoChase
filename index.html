<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>GPX Drawing tool</title>
    <!-- Geoportail (IGN) mapping -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Geoportail plugin for Leaflet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/geoportal-leaflet@0.13.0/dist/gp-leaflet.css"/>
    <script src="https://cdn.jsdelivr.net/npm/geoportal-leaflet@0.13.0/dist/gp-leaflet-full.js"></script>
    <style>
        /* ===== CSS Variables ===== */
        :root {
            --primary: #0066cc;
            --primary-dark: #0084ff;
            --secondary: #8b5cf6;
            --secondary-dark: #7c3aed;
            --accent: #10b981;
            --accent-dark: #059669;
            --error: #ef4444;
            --error-dark: #dc2626;
            --text-primary: #1f2937;
            --text-secondary: #94a3b8;
            --border: #e2e8f0;
            --bg-light: rgba(255, 255, 255, 0.95);
            --bg-lighter: rgba(255, 255, 255, 0.8);
            --shadow-sm: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 10px 25px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 25px 50px rgba(0, 0, 0, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
            'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #1a1f2e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #1f2937;
        }

        .container {
            background: var(--bg-light);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 24px;
            box-shadow: var(--shadow-lg), 0 0 1px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 30px 50px 50px 50px;
            max-width: 1400px;
            width: 100%;
        }

        .content-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 45px;
            align-items: start;
        }

        @media (max-width: 1024px) {
            .content-wrapper {
                gap: 35px;
            }
        }

        @media (max-width: 768px) {
            .content-wrapper {
                grid-template-columns: 1fr;
                gap: 30px;
            }

            .container {
                padding: 35px;
            }

            h1 {
                font-size: 32px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 28px;
            }

            button {
                font-size: 14px;
                padding: 14px 20px;
            }
        }

        .form-section {
            min-width: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #gpxForm {
            display: flex;
            flex-direction: column;
            flex: 1;
        }

        #gpxForm .button-group {
            margin-top: auto;
        }

        .map-section {
            min-width: 0;
        }

        #map {
            width: 100%;
            height: 550px;
            border-radius: 16px;
            border: 2px solid #e2e8f0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
        }

        #map:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        }

        h1 {
            color: #0f172a;
            margin-bottom: 12px;
            font-size: 42px;
            font-weight: 700;
            text-align: center;
            letter-spacing: -0.5px;
            background: linear-gradient(135deg, var(--primary) 0%, #00a8e8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .form-group {
            margin-bottom: 28px;
        }

        label {
            display: block;
            color: #1f2937;
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 14px;
        }

        input[type='number'],
        input[type='text'] {
            width: 100%;
            padding: 14px 18px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            transition: all 0.25s ease;
            outline: none;
            background: rgba(255, 255, 255, 0.8);
            font-family: inherit;
            color: #1f2937;
        }

        input[type='number']::placeholder,
        input[type='text']::placeholder {
            color: var(--muted);
        }

        input[type='number']:focus,
        input[type='text']:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 4px rgba(0, 102, 204, 0.08),
            0 4px 12px rgba(0, 102, 204, 0.12);
            background: var(--bg-light);
        }

        .input-hint {
            color: #94a3b8;
            font-size: 13px;
            margin-top: 6px;
            font-weight: 400;
        }

        .input-error {
            color: #991b1b;
            font-size: 13px;
            margin-top: 6px;
            font-weight: 500;
            display: none;
            animation: slideIn 0.2s ease;
        }

        .input-error.show {
            display: block;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 40px;
        }

        button {
            flex: 1;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            outline: none;
        }

        .btn-generate {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(0, 102, 204, 0.25);
            position: relative;
            overflow: hidden;
        }

        .btn-generate::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn-generate:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 102, 204, 0.35);
        }

        .btn-generate:hover::before {
            left: 100%;
        }

        .btn-generate:active {
            transform: translateY(-1px);
        }

        .btn-generate:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .output {
            margin-top: 30px;
            padding: 18px 22px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.05) 0%, rgba(6, 182, 212, 0.05) 100%);
            border-radius: 12px;
            display: none;
            border-left: 4px solid var(--accent);
            animation: slideIn 0.3s ease;
        }

        .output.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.05) 0%, rgba(244, 63, 94, 0.05) 100%);
            border-left-color: var(--error);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: var(--shadow-md);
            border-left: 4px solid var(--accent);
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 2000;
            animation: slideInRight 0.3s ease;
            max-width: 400px;
        }

        .toast.success {
            border-left-color: var(--accent);
        }

        .toast.error {
            border-left-color: var(--error);
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-content {
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
            line-height: 1.4;
        }

        .toast.success .toast-content {
            color: #047857;
        }

        .toast.error .toast-content {
            color: #991b1b;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(400px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideOutRight {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(400px);
            }
        }

        .toast.fade-out {
            animation: slideOutRight 0.3s ease;
        }

        @media (max-width: 768px) {
            .toast {
                right: 12px;
                left: 12px;
                max-width: none;
            }
        }

        .output-title {
            font-weight: 700;
            color: #065f46;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .output.error .output-title {
            color: #7f1d1d;
        }

        .output-content {
            color: #047857;
            font-size: 14px;
            line-height: 1.6;
            font-weight: 500;
        }

        .output.error .output-content {
            color: #991b1b;
        }

        /* Line segments styling */
        .line-segments-section {
            margin-top: 45px;
            padding-top: 35px;
            border-top: 2px solid #e2e8f0;
        }

        .line-segments-title {
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 20px;
            font-size: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .line-segment-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.5) 0%, rgba(248, 250, 252, 0.8) 100%);
            border-radius: 14px;
            padding: 20px;
            margin-bottom: 16px;
            border: 2px solid #e2e8f0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .line-segment-item:hover {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(0, 102, 204, 0.03) 0%, rgba(0, 132, 255, 0.03) 100%);
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.08);
        }

        .segment-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 18px;
        }

        .segment-number {
            font-weight: 700;
            color: #0066cc;
            font-size: 14px;
        }

        .btn-remove-segment {
            padding: 0;
            width: 32px;
            height: 32px;
            font-size: 28px;
            font-weight: 300;
            background: transparent;
            color: #ef4444;
            border: none;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            position: absolute;
            top: 12px;
            right: 12px;
        }

        .btn-remove-segment:hover {
            background: transparent;
            color: #dc2626;
            transform: scale(1.15);
        }

        .btn-remove-segment:active {
            transform: scale(0.95);
        }

        .segment-input-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 14px;
            margin-bottom: 14px;
        }

        .radio-group {
            display: flex;
            gap: 16px;
            margin-bottom: 14px;
            padding: 14px;
            background: rgba(248, 250, 252, 0.7);
            border-radius: 10px;
            border: 1px solid #e2e8f0;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            flex: 1;
        }

        .radio-option input[type='radio'] {
            cursor: pointer;
            width: 18px;
            height: 18px;
            accent-color: #0066cc;
        }

        .radio-option label {
            margin: 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
        }

        .conditional-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 12px;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .conditional-inputs.hidden {
            display: none;
        }

        .btn-add-segment {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 14px 22px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-size: 14px;
            border: none;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.25);
        }

        .btn-add-segment:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.35);
        }

        .btn-add-segment:active {
            transform: translateY(0);
        }

        /* Top bar with title and project selector */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            gap: 20px;
        }

        .top-bar h1 {
            margin: 0;
            flex: 1;
        }

        /* Project selector styles */
        .project-selector {
            flex: 0 0 280px;
        }

        .project-search-wrapper {
            position: relative;
            display: flex;
            gap: 0;
            align-items: stretch;
        }

        #projectSearch {
            flex: 1;
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 13px;
            outline: none;
            background: rgba(255, 255, 255, 0.8);
            color: #1f2937;
            font-family: inherit;
            transition: all 0.25s ease;
            min-width: 0;
        }

        #projectSearch:focus {
            border-color: #0066cc;
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.08),
            0 2px 8px rgba(0, 102, 204, 0.12);
            background: rgba(255, 255, 255, 0.95);
        }

        #projectSearch::placeholder {
            color: #cbd5e1;
        }

        @media (max-width: 1024px) {
            .top-bar {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .project-selector {
                flex: 0 0 auto;
                width: 100%;
            }

            .top-bar h1 {
                margin-bottom: 0;
            }
        }

        .project-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
            max-height: 300px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            margin-top: 4px;
        }

        .project-dropdown.show {
            display: block;
        }

        .project-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.15s ease;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .project-item:last-child {
            border-bottom: none;
        }

        .project-item:hover {
            background: rgba(0, 102, 204, 0.05);
        }

        .project-item.selected {
            background: rgba(0, 102, 204, 0.1);
            color: #0066cc;
            font-weight: 500;
        }

        .project-item-name {
            flex: 1;
            color: #1f2937;
            font-size: 14px;
        }

        .project-item-delete {
            color: #ef4444;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
            transition: all 0.15s ease;
            border-radius: 6px;
        }

        .project-item-delete:hover {
            background: rgba(239, 68, 68, 0.1);
            transform: scale(1.1);
        }

        .btn-save-project {
            background: linear-gradient(135deg, var(--secondary) 0%, var(--secondary-dark) 100%);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-size: 15px;
            border: none;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.25);
        }

        .btn-save-project:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.35);
        }

        .btn-save-project:active {
            transform: translateY(-1px);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .button-group {
                grid-template-columns: 1fr;
            }
        }

        /* Dropdown menu for save button */
        .dropdown-menu-container {
            position: relative;
        }

        .dropdown-menu {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            margin-bottom: 8px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            display: block;
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: transparent;
            color: var(--text);
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }

        .dropdown-item:hover {
            background-color: rgba(16, 185, 129, 0.2);
        }

        .dropdown-item:active {
            background-color: rgba(16, 185, 129, 0.3);
        }

        /* ===== LAYERS PANEL ===== */
        .layers-panel {
            background: var(--bg-light);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .layers-panel-title {
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 12px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .layers-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .layers-empty {
            text-align: center;
            padding: 20px 10px;
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* ===== ACTION BUTTONS ===== */
        .btn-action {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            border: none;
            box-shadow: 0 4px 15px rgba(0, 102, 204, 0.25);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-action:hover {
            opacity: 0.9;
        }

        .btn-action:active {
            opacity: 0.8;
        }

        .btn-action-icon {
            font-size: 18px;
        }

        /* ===== MODAL ===== */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: rgba(15, 23, 42, 0.9);
            color: var(--text);
            border-radius: 16px;
            border: 1px solid var(--panel-border);
            box-shadow: var(--shadow);
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 24px 28px;
            animation: slideIn 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-header-icon {
            font-size: 24px;
        }

        .modal-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .modal-form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .modal-form-group label {
            font-weight: 600;
            color: var(--muted);
            font-size: 14px;
        }

        .modal-form-group input {
            padding: 12px 14px;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.25s ease;
            outline: none;
        }

        .modal-form-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.08);
        }

        .modal-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 24px;
        }

        .modal-btn {
            padding: 12px 20px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            border: none;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .modal-btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.2);
        }

        .modal-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 102, 204, 0.3);
        }

        .modal-btn-secondary {
            background: transparent;
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .modal-btn-secondary:hover {
            background: var(--bg-lighter);
            border-color: var(--primary);
        }

        /* Modal Close Button */
        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        /* Layers Panel Section */
        .layers-panel-section {
            margin-top: 15px;
            padding-top: 15px;
        }

        .layers-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .layers-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .layers-actions {
            display: flex;
            gap: 12px;
            flex-wrap: nowrap;
            width: 100%;
        }

        .layers-actions .btn-action {
            flex: 1;
            background: rgba(0, 0, 0, 0.5);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 400;
            font-size: 12px;
            border: 1px solid var(--panel-border);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .layers-actions .btn-action:hover {
            background: rgba(0, 0, 0, 0.6);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .layers-actions .btn-action:active {
            transform: scale(0.96);
        }

        .layers-panel {
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--bg-lighter);
            max-height: 400px;
            overflow-y: auto;
        }

        .layers-empty-state {
            padding: 30px 20px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .layer-item {
            padding: 12px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .layer-item:hover {
            opacity: 0.8;
        }

        .layer-item-info {
            flex: 1;
            min-width: 0;
        }

        .layer-item-name {
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 14px;
        }

        .layer-item-type {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .layer-item-actions {
            display: flex;
            gap: 6px;
            margin-left: 10px;
        }

        .layer-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .layer-action-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
            color: var(--text-primary);
        }

        .layer-action-btn.delete:hover {
            color: var(--error);
            background-color: rgba(239, 68, 68, 0.1);
        }

        /* ===== SAVED COORDINATES SECTION ===== */
        .saved-coordinates-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--border);
        }

        .saved-coordinates-form {
            background: var(--bg-lighter);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .saved-coordinates-form .modal-form-group {
            gap: 6px;
        }

        .saved-coordinates-form .modal-form-group label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .saved-coordinates-form .modal-form-group input {
            font-size: 13px;
            padding: 10px;
        }

        .saved-coordinates-form #saveCoordinateBtn {
            width: 100%;
            margin-top: 4px;
        }

        .saved-coordinates-list {
            background: var(--bg-lighter);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            max-height: 250px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .saved-coordinate-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .saved-coordinate-item:hover {
            background: var(--bg-light);
            border-color: var(--primary);
        }

        .saved-coordinate-item-info {
            flex: 1;
            min-width: 0;
        }

        .saved-coordinate-item-name {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-coordinate-item-value {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-coordinate-item-actions {
            display: flex;
            gap: 6px;
            margin-left: 10px;
            flex-shrink: 0;
        }

        .coordinate-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            color: var(--primary);
            transition: all 0.2s ease;
            white-space: nowrap;
            font-weight: 500;
        }

        .coordinate-action-btn:hover {
            background-color: rgba(0, 102, 204, 0.1);
            color: var(--primary-dark);
        }

        .coordinate-action-btn.delete {
            color: var(--error);
        }

        .coordinate-action-btn.delete:hover {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--error);
        }

        /* ===== COORDINATE INPUT WRAPPER ===== */
        .coordinate-input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
        }

        .coordinate-input-wrapper input {
            flex: 1;
        }

        .btn-load-coordinate {
            background: none;
            border: 1px solid var(--border);
            cursor: pointer;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 16px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 40px;
            min-height: 40px;
            flex-shrink: 0;
        }

        .btn-load-coordinate:hover {
            background-color: rgba(0, 102, 204, 0.1);
            border-color: var(--primary);
        }

        .btn-load-coordinate:active {
            background-color: rgba(0, 102, 204, 0.2);
        }

        /* ===== COORDINATE PICKER DROPDOWN ===== */
        .coordinate-picker-dropdown {
            position: fixed;
            background: white;
            border: 2px solid var(--border);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            min-width: 280px;
            max-width: 380px;
            max-height: 320px;
            overflow-y: auto;
            display: none;
            flex-direction: column;
        }

        .coordinate-picker-dropdown.show {
            display: flex;
        }

        .coordinate-picker-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .coordinate-picker-list {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .coordinate-picker-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--bg-lighter);
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .coordinate-picker-item:hover {
            background-color: var(--bg-lighter);
        }

        .coordinate-picker-item:last-child {
            border-bottom: none;
        }

        .coordinate-picker-item-name {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 13px;
        }

        .coordinate-picker-item-value {
            font-size: 12px;
            color: var(--text-secondary);
            font-family: monospace;
        }

        .coordinate-picker-empty {
            padding: 24px 16px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* Base */
        :root {
            --bg: #0f172a;
            --panel: rgba(15, 23, 42, 0.78); /* #0f172a + opacity */
            --panel-border: rgba(148, 163, 184, 0.15);
            --text: #f1f5f9;
            --muted: #94a3b8;
            --accent: #3b82f6;
            --accent-600: #2563eb;
            --accent-700: #1d4ed8;
            --success: #10b981;
            --danger: #ef4444;
            --shadow: 0 10px 30px rgba(2, 6, 23, 0.35);
        }

        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            overflow: hidden; /* map is fullscreen; sidebar handles its own scroll */
        }

        /* Fullscreen Map */
        #map {
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
        }

        .leaflet-container {
            background: #0b1020;
        }

        /* Remove grab cursor from map interaction */
        .leaflet-grab,
        .leaflet-grab:active {
            cursor: default !important;
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            left: -320px;
            height: 100vh;
            width: 320px;
            background: var(--panel);
            backdrop-filter: blur(14px);
            -webkit-backdrop-filter: blur(14px);
            border-right: 1px solid var(--panel-border);
            box-shadow: var(--shadow);
            z-index: 1000;
            color: var(--text);
            transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-inner {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 16px;
            height: 100%;
            overflow-y: auto;
            padding-bottom: 96px; /* space for sticky footer buttons */
        }

        .sidebar-section {
            padding: 8px 4px;
        }

        .sidebar-section-title {
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--muted);
            margin: 0 0 8px 4px;
        }

        /* Toggle Button - positioned on the right edge of sidebar */
        .sidebar-toggle {
            position: absolute;
            top: 50%;
            right: -40px;
            transform: translateY(-50%);
            z-index: 1050;
            width: 40px;
            height: 80px;
            border-radius: 0 12px 12px 0;
            border: 1px solid var(--panel-border);
            border-left: none;
            background: rgba(2, 6, 23, 0.85);
            color: var(--text);
            font-size: 18px;
            cursor: pointer;
            box-shadow: var(--shadow);
            transition: box-shadow 0.3s ease, background 0.3s ease;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 4px;
        }

        .sidebar-toggle:hover {
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.35), var(--shadow);
            background: rgba(2, 6, 23, 0.95);
        }

        .sidebar-toggle:active {
            transform: translateY(-50%) scale(0.95);
        }

        /* Buttons (override legacy classes to dark theme) */
        .btn-action,
        .btn-save-project,
        .btn-generate,
        .modal-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 14px;
            border-radius: 12px;
            border: 1px solid var(--panel-border);
            background: rgba(148, 163, 184, 0.08);
            color: var(--text);
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .btn-action:hover,
        .btn-save-project:hover,
        .btn-generate:hover,
        .modal-btn:hover {
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.35), 0 8px 24px rgba(0, 0, 0, 0.25);
        }

        .btn-action:active,
        .btn-save-project:active,
        .btn-generate:active,
        .modal-btn:active {
            transform: translateY(1px) scale(0.98);
        }

        /* Primary emphasis */
        .btn-generate, .modal-btn-primary {
            background: linear-gradient(180deg, var(--accent), var(--accent-600));
            border-color: transparent;
        }

        .btn-generate:hover, .modal-btn-primary:hover {
            filter: brightness(1.06);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.45);
        }

        /* Inputs */
        #projectSearch, .modal input, .modal textarea, .modal select {
            background: rgba(2, 6, 23, 0.72); /* darker for contrast on light modals */
            border: 1px solid var(--panel-border);
            color: var(--text);
            -webkit-text-fill-color: var(--text); /* Safari */
            caret-color: var(--text);
            border-radius: 10px;
        }

        /* Modal placeholders */
        .modal input::placeholder,
        .modal textarea::placeholder {
            color: rgba(241, 245, 249, 0.5) !important;
            opacity: 0.5 !important;
        }

        .modal input::-webkit-input-placeholder,
        .modal textarea::-webkit-input-placeholder {
            color: rgba(241, 245, 249, 0.5) !important;
            opacity: 0.5 !important;
            -webkit-text-fill-color: rgba(241, 245, 249, 0.5) !important;
        }

        .modal input::-moz-placeholder,
        .modal textarea::-moz-placeholder {
            color: rgba(241, 245, 249, 0.5) !important;
            opacity: 0.5 !important;
        }

        .modal input:-ms-input-placeholder,
        .modal textarea:-ms-input-placeholder,
        .modal input::-ms-input-placeholder,
        .modal textarea::-ms-input-placeholder {
            color: rgba(241, 245, 249, 0.5) !important;
            opacity: 0.5 !important;
        }

        /* Modal filled/empty visual differentiation */
        .modal input:placeholder-shown,
        .modal textarea:placeholder-shown {
            border-color: var(--panel-border);
        }
        .modal input:not(:placeholder-shown),
        .modal textarea:not(:placeholder-shown) {
            border-color: var(--accent);
            background: rgba(2, 6, 23, 0.82);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12);
        }

        .modal input:focus,
        .modal textarea:focus,
        .modal select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
            background: rgba(2, 6, 23, 0.82);
        }

        /* Modern line segment mode select */
        #lineSegmentMode {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            padding: 12px 40px 12px 16px;
            font-size: 15px;
            font-weight: 500;
            letter-spacing: 0.3px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%);
            border: 2px solid rgba(148, 163, 184, 0.3);
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23f1f5f9' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px;
            padding-right: 45px;
        }

        #lineSegmentMode:hover {
            border-color: rgba(148, 163, 184, 0.6);
            background-color: rgba(30, 41, 59, 0.99);
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.1);
        }

        #lineSegmentMode:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2), 0 4px 16px rgba(16, 185, 129, 0.15);
            background-color: rgba(30, 41, 59, 0.99);
        }

        #lineSegmentMode option {
            background: rgba(15, 23, 42, 0.95);
            color: #f1f5f9;
            padding: 12px 16px;
            border: none;
            border-radius: 6px;
            margin: 4px 0;
        }

        #lineSegmentMode option:hover {
            background: var(--accent);
            color: white;
        }

        #lineSegmentMode option:checked {
            background: linear-gradient(135deg, var(--accent) 0%, #059669 100%);
            color: white;
            font-weight: 500;
        }

        /* Improve readability if the browser applies autofill styles in modals */
        .modal input:-webkit-autofill,
        .modal input:-webkit-autofill:hover,
        .modal input:-webkit-autofill:focus {
            -webkit-text-fill-color: var(--text);
            caret-color: var(--text);
            transition: background-color 9999s ease-out 0s;
        }

        /* Project search placeholder + filled state */
        #projectSearch::placeholder,
        #projectSearch::-webkit-input-placeholder,
        #projectSearch::-moz-placeholder,
        #projectSearch:-ms-input-placeholder,
        #projectSearch::-ms-input-placeholder {
            color: var(--muted) !important;
        }
        #projectSearch:not(:placeholder-shown) {
            border-color: var(--accent);
            background: rgba(2, 6, 23, 0.82);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12);
        }

        /* Layers panel tweaks inside sidebar */
        #layersPanel {
            background: transparent;
            border: 1px dashed var(--panel-border);
            border-radius: 12px;
        }

        .layers-empty-state, .layers-empty {
            color: var(--muted);
        }

        /* Fix layer item text visibility in dark sidebar */
        .sidebar .layer-item-name {
            color: var(--text);
        }

        .sidebar .layer-item-type {
            color: var(--muted);
        }

        /* Make legacy container invisible after script moves content (failsafe) */
        body.sidebar-ready .container {
            display: none !important;
        }

        /* Leaflet control tweaks for dark */
        .leaflet-control-zoom a {
            background: rgba(2, 6, 23, 0.7);
            color: var(--text);
            border: 1px solid var(--panel-border);
        }

        .leaflet-control-zoom a:hover {
            background: rgba(2, 6, 23, 0.85);
        }

        /* Sticky footer for action buttons */
        .sidebar-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            padding: 12px 16px;
            background: linear-gradient(180deg, rgba(2, 6, 23, 0) 0%, rgba(2, 6, 23, 0.55) 20%, rgba(2, 6, 23, 0.75) 60%, rgba(2, 6, 23, 0.92) 100%);
            border-top: 1px solid var(--panel-border);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            z-index: 1001;
        }

        .sidebar-footer .button-group {
            display: flex;
            align-items: stretch;
            justify-content: space-between;
            gap: 8px;
            margin: 0;
            flex-wrap: nowrap;
        }

        .sidebar-footer .button-group > button {
            flex: 1 1 0;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            padding: 10px 12px;
        }
        /* Readable inputs inside sidebar */
        .sidebar input[type="text"],
        .sidebar input[type="number"],
        .sidebar input[type="email"],
        .sidebar input[type="search"],
        .sidebar input[type="password"],
        .sidebar textarea,
        .sidebar select {
            background: rgba(148, 163, 184, 0.12);
            border: 1px solid var(--panel-border);
            color: var(--text);
            -webkit-text-fill-color: var(--text); /* Safari */
            caret-color: var(--text);
            border-radius: 10px;
        }

        /* Sidebar placeholders */
        .sidebar input::placeholder,
        .sidebar textarea::placeholder,
        .sidebar input::-webkit-input-placeholder,
        .sidebar textarea::-webkit-input-placeholder,
        .sidebar input::-moz-placeholder,
        .sidebar textarea::-moz-placeholder,
        .sidebar input:-ms-input-placeholder,
        .sidebar textarea:-ms-input-placeholder,
        .sidebar input::-ms-input-placeholder,
        .sidebar textarea::-ms-input-placeholder {
            color: #a0aec0 !important;
        }

        /* Sidebar filled/empty visual differentiation */
        .sidebar input:placeholder-shown,
        .sidebar textarea:placeholder-shown {
            border-color: var(--panel-border);
        }
        .sidebar input:not(:placeholder-shown),
        .sidebar textarea:not(:placeholder-shown) {
            border-color: var(--accent);
            background: rgba(148, 163, 184, 0.18);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.12);
        }

        .sidebar input:focus,
        .sidebar textarea:focus,
        .sidebar select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
            background: rgba(148, 163, 184, 0.18);
        }

        /* Improve readability if the browser applies autofill styles */
        .sidebar input:-webkit-autofill,
        .sidebar input:-webkit-autofill:hover,
        .sidebar input:-webkit-autofill:focus {
            -webkit-text-fill-color: var(--text);
            caret-color: var(--text);
            transition: background-color 9999s ease-out 0s;
        }
    </style>
</head>
<body>
<aside id="sidebar" class="sidebar open">
    <button id="sidebarToggle" class="sidebar-toggle" aria-label="Toggle sidebar" aria-pressed="true">‚Üê</button>
    <div class="sidebar-inner">
        <div class="sidebar-section" id="projectMount">
            <!-- Project selector will be moved here -->
        </div>
        <div class="sidebar-section">
            <div class="sidebar-section-title">Drawing Tools</div>
            <!-- The entire form (gpxForm) including buttons and layersPanel will be moved below into formMount -->
        </div>
        <div class="sidebar-section" id="formMount">
            <!-- gpxForm will be moved here -->
        </div>
        <div class="sidebar-section" id="statusMount">
            <!-- output/status will be moved here -->
        </div>
    </div>
    <div class="sidebar-footer" id="actionsFooter">
        <!-- action buttons will be moved here -->
    </div>
</aside>

<div class="container">
    <div class="top-bar">
        <h1>GPX Drawing tool</h1>
        <!-- Project Selector -->
        <div class="project-selector">
            <div class="project-search-wrapper">
                <input
                        type="text"
                        id="projectSearch"
                        placeholder="Load project"
                        autocomplete="off"
                />
                <div class="project-dropdown" id="projectDropdown"></div>
            </div>
        </div>
    </div>
    <div class="content-wrapper">
        <div class="form-section">
            <form id="gpxForm">

                <!-- Centers and Radius (Hidden for new layer-based UX) -->
                <div class="form-group" style="display: none;">
                    <label for="coordinates">Centers</label>
                    <input
                            type="text"
                            id="coordinates"
                            placeholder="48.8566, 2.3522, 48.9, 2.4, 49.0, 2.5"
                    />
                    <div class="input-hint">
                        Enter one or more center points as: lat, lon [, lat, lon, ...]
                    </div>
                    <div class="input-error" id="coordinatesError"></div>
                </div>

                <div class="form-group" style="display: none;">
                    <label for="radius">Radius (km)</label>
                    <input type="text" id="radius" placeholder="1.0, 2.5, 5.0"/>
                    <div class="input-hint">
                        Circle radius in kilometers (supports multiple radii separated by comma or space)
                    </div>
                    <div class="input-error" id="radiusError"></div>
                </div>

                <!-- Layers Panel Section -->
                <div class="layers-panel-section">
                    <div class="layers-header">
                        <div class="layers-actions">
                            <button type="button" class="btn-action" id="addCircleBtn" title="Add a new circle">
                                üîµ Circle
                            </button>
                            <button type="button" class="btn-action" id="addLineSegmentBtn"
                                    title="Add a new line segment">
                                ‚ûñ Line
                            </button>
                            <button type="button" class="btn-action" id="addPointBtn" title="Add a new point">
                                üìç Point
                            </button>
                        </div>
                    </div>
                    <div class="layers-panel" id="layersPanel">
                        <div class="layers-empty-state">
                            No elements added yet. Use the buttons above to add circles, line segments, or points.
                        </div>
                    </div>
                </div>

                <div class="button-group">
                    <button type="button" class="btn-action" id="manageSavedCoordinatesBtn" title="Manage Coordinates">
                        üóÇÔ∏è Coords
                    </button>
                    <div class="dropdown-menu-container">
                        <button type="button" class="btn-save-project" id="saveProjectBtn" title="Save or Export Project">
                            üíæ Save
                        </button>
                        <div class="dropdown-menu" id="saveDropdownMenu">
                            <button type="button" class="dropdown-item" id="saveProjectOption">Save Project</button>
                            <button type="button" class="dropdown-item" id="exportDataOption">Export JSON</button>
                            <button type="button" class="dropdown-item" id="importDataOption">Import JSON</button>
                        </div>
                    </div>
                    <button type="submit" class="btn-generate" title="Download GPX">üì• GPX</button>
                </div>
                <input type="file" id="importFileInput" style="display: none;" accept=".json" />
            </form>

            <div id="output" class="output">
                <div class="output-title">Status</div>
                <div class="output-content" id="outputMessage"></div>
            </div>
        </div>

        <div class="map-section">
            <div id="map"></div>
        </div>
    </div>
</div>

<!-- Circle Modal -->
<div class="modal-overlay" id="circleModal">
    <div class="modal">
        <div class="modal-header">
            <h2 id="circleModalTitle">Add Circle</h2>
        </div>
        <form id="circleForm" class="modal-form">
            <div class="modal-form-group">
                <label for="circleName">Circle Name (optional)</label>
                <input type="text" id="circleName" placeholder="e.g., Search Area, Zone 1"/>
            </div>
            <div class="modal-form-group">
                <label for="circleCenter">Center Coordinates</label>
                <div class="coordinate-input-wrapper">
                    <input type="text" id="circleCenter" placeholder="48.8566, 2.3522" required/>
                    <button type="button" class="btn-load-coordinate" onclick="showLoadCoordinateMenu('circleCenter')">
                        üìç
                    </button>
                </div>
                <div class="input-hint">Latitude, Longitude</div>
            </div>
            <div class="modal-form-group">
                <label for="circleRadius">Radius (km)</label>
                <input type="text" id="circleRadius" placeholder="1.0" required/>
            </div>
            <div class="modal-actions">
                <button type="button" class="modal-btn modal-btn-secondary" id="cancelCircleBtn">Cancel</button>
                <button type="submit" class="modal-btn modal-btn-primary">Add Circle</button>
            </div>
        </form>
    </div>
</div>

<!-- Line Segment Modal -->
<div class="modal-overlay" id="lineSegmentModal">
    <div class="modal">
        <div class="modal-header">
            <h2 id="lineSegmentModalTitle">Add Line Segment</h2>
        </div>
        <form id="lineSegmentForm" class="modal-form">
            <div class="modal-form-group">
                <label for="lineSegmentName">Line Segment Name (optional)</label>
                <input type="text" id="lineSegmentName" placeholder="e.g., Path 1, Route A"/>
            </div>
            <div class="modal-form-group">
                <label for="lineSegmentCenter">Center Coordinates</label>
                <div class="coordinate-input-wrapper">
                    <input type="text" id="lineSegmentCenter" placeholder="48.8566, 2.3522" required/>
                    <button type="button" class="btn-load-coordinate"
                            onclick="showLoadCoordinateMenu('lineSegmentCenter')">üìç
                    </button>
                </div>
                <div class="input-hint">Latitude, Longitude</div>
            </div>
            <div class="modal-form-group">
                <label for="lineSegmentMode">Mode</label>
                <select id="lineSegmentMode" required>
                    <option value="coordinate">Endpoint (by coordinates)</option>
                    <option value="azimuth">Azimuth (by bearing and distance)</option>
                    <option value="intersection">Intersection (by point and distance)</option>
                </select>
            </div>
            <div id="coordinateMode" class="modal-form-group">
                <label for="lineSegmentEndpoint">Endpoint Coordinates</label>
                <div class="coordinate-input-wrapper">
                    <input type="text" id="lineSegmentEndpoint" placeholder="48.9, 2.4"/>
                    <button type="button" class="btn-load-coordinate"
                            onclick="showLoadCoordinateMenu('lineSegmentEndpoint')">üìç
                    </button>
                </div>
                <div class="input-hint">Latitude, Longitude</div>
            </div>
            <div class="modal-form-group azimuth-mode" style="display: none;">
                <label for="lineSegmentAzimuth">Azimuth (degrees)</label>
                <input type="text" id="lineSegmentAzimuth" placeholder="45"/>
            </div>
            <div class="modal-form-group azimuth-mode" style="display: none;">
                <label for="lineSegmentDistance">Distance (km)</label>
                <input type="text" id="lineSegmentDistance" placeholder="5.0"/>
            </div>
            <div class="modal-form-group intersection-mode" style="display: none;">
                <label for="lineSegmentIntersectionPoint">Intersection Point</label>
                <div class="coordinate-input-wrapper">
                    <input type="text" id="lineSegmentIntersectionPoint" placeholder="48.9, 2.4"/>
                    <button type="button" class="btn-load-coordinate"
                            onclick="showLoadCoordinateMenu('lineSegmentIntersectionPoint')">üìç
                    </button>
                </div>
                <div class="input-hint">Latitude, Longitude - Line will pass through this point</div>
            </div>
            <div class="modal-form-group intersection-mode" style="display: none;">
                <label for="lineSegmentIntersectionDistance">Distance (km)</label>
                <input type="text" id="lineSegmentIntersectionDistance" placeholder="5.0"/>
                <div class="input-hint">Total length of the line segment</div>
            </div>
            <div class="modal-actions">
                <button type="button" class="modal-btn modal-btn-secondary" id="cancelLineSegmentBtn">Cancel</button>
                <button type="submit" class="modal-btn modal-btn-primary">Add Line</button>
            </div>
        </form>
    </div>
</div>

<!-- Point Modal -->
<div class="modal-overlay" id="pointModal">
    <div class="modal">
        <div class="modal-header">
            <h2 id="pointModalTitle">Add Point</h2>
        </div>
        <form id="pointForm" class="modal-form">
            <div class="modal-form-group">
                <label for="pointName">Point Name (optional)</label>
                <input type="text" id="pointName" placeholder="e.g., Waypoint 1, Landmark"/>
            </div>
            <div class="modal-form-group">
                <label for="pointCoordinates">Coordinates</label>
                <div class="coordinate-input-wrapper">
                    <input type="text" id="pointCoordinates" placeholder="48.8566, 2.3522" required/>
                    <button type="button" class="btn-load-coordinate"
                            onclick="showLoadCoordinateMenu('pointCoordinates')">üìç
                    </button>
                </div>
                <div class="input-hint">Latitude, Longitude</div>
            </div>
            <div class="modal-actions">
                <button type="button" class="modal-btn modal-btn-secondary" id="cancelPointBtn">Cancel</button>
                <button type="submit" class="modal-btn modal-btn-primary">Add Point</button>
            </div>
        </form>
    </div>
</div>

<!-- Filename Modal -->
<div class="modal-overlay" id="filenameModal">
    <div class="modal">
        <div class="modal-header">
            <h2 id="filenameModalTitle">Save File</h2>
        </div>
        <form id="filenameForm" class="modal-form">
            <div class="modal-form-group">
                <label for="filenameInput">Filename</label>
                <input type="text" id="filenameInput" placeholder="filename.gpx" required/>
                <div class="input-hint">The .gpx extension will be added automatically if not provided</div>
            </div>
            <div class="modal-actions">
                <button type="button" class="modal-btn modal-btn-secondary" id="cancelFilenameBtn">Cancel</button>
                <button type="submit" class="modal-btn modal-btn-primary" id="confirmFilenameBtn">Download</button>
            </div>
        </form>
    </div>
</div>

<!-- Saved Coordinates Modal -->
<div class="modal-overlay" id="savedCoordinatesModal">
    <div class="modal">
        <div class="modal-header">
            <h2>Manage Saved Coordinates</h2>
        </div>
        <div class="modal-form">
            <div class="modal-form-group">
                <label for="coordinateName">Coordinate Name</label>
                <input type="text" id="coordinateName" placeholder="e.g., Paris Center"/>
            </div>
            <div class="modal-form-group">
                <label for="coordinateValue">Latitude, Longitude</label>
                <input type="text" id="coordinateValue" placeholder="48.8566, 2.3522"/>
            </div>
            <button type="button" class="modal-btn modal-btn-primary" id="saveCoordinateBtn" style="width: 100%;">üíæ Save
                Coordinate
            </button>

            <div style="margin-top: 24px; padding-top: 20px; border-top: 2px solid var(--border);">
                <h3 style="font-size: 14px; font-weight: 600; margin-bottom: 12px; color: var(--text-primary);">Saved
                    Coordinates</h3>
                <div class="saved-coordinates-list" id="savedCoordinatesList">
                    <div class="layers-empty">No saved coordinates yet.</div>
                </div>
            </div>
        </div>

        <div class="modal-actions" style="margin-top: 20px;">
            <button type="button" class="modal-btn modal-btn-secondary" id="cancelSavedCoordinatesBtn">Close</button>
        </div>
    </div>
</div>

<script>
    // ===== UTILITY FUNCTIONS: COORDINATES & CALCULATIONS =====
    // Convert degrees to radians
    function toRadians(degrees) {
        return (degrees * Math.PI) / 180;
    }

    // Convert radians to degrees
    function toDegrees(radians) {
        return (radians * 180) / Math.PI;
    }

    // Calculate destination point given distance and bearing from start point
    function destinationPoint(lat, lon, distance, bearing) {
        const R = 6371; // Earth's radius in km
        const Œ¥ = distance / R; // angular distance
        const Œ∏ = toRadians(bearing);

        const œÜ1 = toRadians(lat);
        const Œª1 = toRadians(lon);

        const œÜ2 = Math.asin(Math.sin(œÜ1) * Math.cos(Œ¥) + Math.cos(œÜ1) * Math.sin(Œ¥) * Math.cos(Œ∏));

        const Œª2 =
            Œª1 +
            Math.atan2(
                Math.sin(Œ∏) * Math.sin(Œ¥) * Math.cos(œÜ1),
                Math.cos(Œ¥) - Math.sin(œÜ1) * Math.sin(œÜ2)
            );

        return {
            lat: toDegrees(œÜ2),
            lon: toDegrees(Œª2),
        };
    }

    // Calculate bearing between two points
    function calculateBearing(fromLat, fromLon, toLat, toLon) {
        const œÜ1 = toRadians(fromLat);
        const Œª1 = toRadians(fromLon);
        const œÜ2 = toRadians(toLat);
        const Œª2 = toRadians(toLon);

        const ŒîŒª = Œª2 - Œª1;

        const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
        const x = Math.cos(œÜ1) * Math.sin(œÜ2) - Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);
        const bearing = toDegrees(Math.atan2(y, x));

        return (bearing + 360) % 360;
    }

    // Calculate distance between two points (haversine)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth's radius in km
        const œÜ1 = toRadians(lat1);
        const œÜ2 = toRadians(lat2);
        const ŒîœÜ = toRadians(lat2 - lat1);
        const ŒîŒª = toRadians(lon2 - lon1);

        const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
            Math.cos(œÜ1) * Math.cos(œÜ2) *
            Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }

    // Web Mercator projection helpers (EPSG:3857)
    function mercatorProject(lat, lon) {
        const R = 6378137; // meters
        const Œª = toRadians(lon);
        let œÜ = toRadians(lat);
        // Clamp latitude to prevent infinity at the poles
        const maxLat = 85.05112878;
        if (lat > maxLat) œÜ = toRadians(maxLat);
        if (lat < -maxLat) œÜ = toRadians(-maxLat);
        const x = R * Œª;
        const y = R * Math.log(Math.tan(Math.PI / 4 + œÜ / 2));
        return {x, y};
    }

    function mercatorUnproject(x, y) {
        const R = 6378137; // meters
        const Œª = x / R;
        const œÜ = 2 * Math.atan(Math.exp(y / R)) - Math.PI / 2;
        const lat = toDegrees(œÜ);
        const lon = toDegrees(Œª);
        return {lat, lon};
    }

    // Helper: Convert lat/lon to 3D unit vector on sphere
    function latLonToVector(lat, lon) {
        const œÜ = toRadians(lat);
        const Œª = toRadians(lon);
        return {
            x: Math.cos(œÜ) * Math.cos(Œª),
            y: Math.cos(œÜ) * Math.sin(Œª),
            z: Math.sin(œÜ)
        };
    }

    // Helper: Convert 3D unit vector to lat/lon
    function vectorToLatLon(v) {
        const lat = toDegrees(Math.asin(v.z));
        const lon = toDegrees(Math.atan2(v.y, v.x));
        return {lat, lon};
    }

    // Helper: Cross product of two vectors
    function crossProduct(v1, v2) {
        return {
            x: v1.y * v2.z - v1.z * v2.y,
            y: v1.z * v2.x - v1.x * v2.z,
            z: v1.x * v2.y - v1.y * v2.x
        };
    }

    // Helper: Magnitude of vector
    function magnitude(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    }

    // Helper: Normalize vector to unit length
    function normalize(v) {
        const mag = magnitude(v);
        if (mag === 0) return v;
        return {x: v.x / mag, y: v.y / mag, z: v.z / mag};
    }

    // Helper: Dot product of two vectors
    function dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    }

    // Helper: Rotate vector around an axis by angle (radians) using Rodrigues' formula
    function rotateVector(v, axis, angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const ux = axis.x;
        const uy = axis.y;
        const uz = axis.z;

        return {
            x: v.x * (cos + ux * ux * (1 - cos)) + v.y * (ux * uy * (1 - cos) - uz * sin) + v.z * (ux * uz * (1 - cos) + uy * sin),
            y: v.x * (uy * ux * (1 - cos) + uz * sin) + v.y * (cos + uy * uy * (1 - cos)) + v.z * (uy * uz * (1 - cos) - ux * sin),
            z: v.x * (uz * ux * (1 - cos) - uy * sin) + v.y * (uz * uy * (1 - cos) + ux * sin) + v.z * (cos + uz * uz * (1 - cos))
        };
    }

    // Calculate endpoint from start point through intersection point with specified distance
    // Compute endpoint so that the straight line in Web Mercator from start to end passes through the intersection point,
    // while the geodesic distance from start to end equals the provided distance.
    function endpointFromIntersection(startLat, startLon, intersectLat, intersectLon, distanceKm) {
        const D = distanceKm; // km

        // Project to Web Mercator (meters)
        const P0 = mercatorProject(startLat, startLon);
        const Pi = mercatorProject(intersectLat, intersectLon);

        let vx = Pi.x - P0.x;
        let vy = Pi.y - P0.y;
        let norm = Math.hypot(vx, vy);

        // Fallback direction if start and intersection project to the same point
        if (norm === 0) {
            vx = 1; // east
            vy = 0;
            norm = 1;
        }
        const v = {x: vx / norm, y: vy / norm};

        // s measured in meters along the projection ray from P0
        const sIntersection = Math.hypot(Pi.x - P0.x, Pi.y - P0.y);

        function endFromS(sMeters) {
            const x = P0.x + sMeters * v.x;
            const y = P0.y + sMeters * v.y;
            return mercatorUnproject(x, y); // {lat, lon}
        }

        function f(sMeters) {
            const end = endFromS(sMeters);
            return calculateDistance(startLat, startLon, end.lat, end.lon) - D; // km
        }

        // If requested distance is exactly up to the intersection, return it
        const dStartToInter = calculateDistance(startLat, startLon, intersectLat, intersectLon);
        if (Math.abs(dStartToInter - D) < 1e-6) {
            return {lat: intersectLat, lon: intersectLon};
        }

        // Bracket the root for s >= sIntersection
        let sLow = sIntersection;
        let fLow = f(sLow);

        // If D is smaller than distance to intersection, no solution while keeping the line passing through the point
        // The UI should prevent this; as a fallback, return the intersection to avoid incorrect direction.
        if (fLow > 0) {
            return {lat: intersectLat, lon: intersectLon};
        }

        // Increase sHigh until distance exceeds D (f >= 0)
        let sHigh = sLow + 1000; // start with +1 km in projected meters
        let fHigh = f(sHigh);
        const MAX_S = 40000000; // ~40,000 km in meters, safe upper cap
        let iter = 0;
        while (fHigh < 0 && sHigh < MAX_S && iter < 60) {
            sHigh *= 2;
            fHigh = f(sHigh);
            iter++;
        }

        // If still not bracketed, clamp to max
        if (fHigh < 0) {
            // Fall back to extend along the ray using destination point from current bearing
            const pEnd = endFromS(sHigh);
            return {lat: pEnd.lat, lon: pEnd.lon};
        }

        // Bisection to solve f(s)=0
        let a = sLow, b = sHigh;
        let fa = fLow, fb = fHigh;
        for (let i = 0; i < 60; i++) {
            const mid = 0.5 * (a + b);
            const fm = f(mid);
            if (Math.abs(fm) < 1e-6 || Math.abs(b - a) < 0.01) { // ~1 cm in projected space
                const end = endFromS(mid);
                return {lat: end.lat, lon: end.lon};
            }
            if (fm > 0) {
                b = mid;
                fb = fm;
            } else {
                a = mid;
                fa = fm;
            }
        }
        // Return best mid if not converged
        const end = endFromS(0.5 * (a + b));
        return {lat: end.lat, lon: end.lon};
    }

    // Generate points along a bearing line for specified total distance
    function generateLinePoints(startLat, startLon, endLat, endLon, numPoints) {
        const points = [];

        // Use slerp to generate points between start and end
        const startVec = latLonToVector(startLat, startLon);
        const endVec = latLonToVector(endLat, endLon);

        const dotProd = dotProduct(startVec, endVec);
        const omega = Math.acos(Math.max(-1, Math.min(1, dotProd)));
        const sinOmega = Math.sin(omega);

        // Generate points using slerp interpolation
        for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;

            if (omega < 1e-10) {
                // Points are too close, use linear interpolation
                const lat = startLat + (endLat - startLat) * t;
                const lon = startLon + (endLon - startLon) * t;
                points.push({lat, lon});
            } else {
                // Use slerp for proper great circle interpolation
                const w0 = Math.sin((1 - t) * omega) / sinOmega;
                const w1 = Math.sin(t * omega) / sinOmega;

                const interpVec = {
                    x: w0 * startVec.x + w1 * endVec.x,
                    y: w0 * startVec.y + w1 * endVec.y,
                    z: w0 * startVec.z + w1 * endVec.z
                };

                const normalizedInterp = normalize(interpVec);
                points.push(vectorToLatLon(normalizedInterp));
            }
        }

        return points;
    }

    // Generate circle points
    function generateCircle(centerLat, centerLon, radiusKm, numPoints) {
        const points = [];

        for (let i = 0; i < numPoints; i++) {
            const bearing = (360 / numPoints) * i;
            const point = destinationPoint(centerLat, centerLon, radiusKm, bearing);
            points.push(point);
        }

        // Close the circle by adding the first point again
        points.push(points[0]);

        return points;
    }

    // Generate GPX XML for multiple centers
    function generateMultiCenterGPX(centers, radiiKm, numPoints) {
        const timestamp = new Date().toISOString();
        const radiiDesc =
            radiiKm.length === 1 ? `radius ${radiiKm[0]} km` : `radii ${radiiKm.join(', ')} km`;
        const centersDesc =
            centers.length === 1
                ? `center at ${centers[0].lat}, ${centers[0].lon}`
                : `${centers.length} centers`;

        let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX Circle Generator"
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>Circle Tracks</name>
    <desc>Circular tracks with ${centersDesc} and ${radiiDesc}</desc>
    <time>${timestamp}</time>
  </metadata>
`;

        // Add waypoints for all centers
        centers.forEach((center, centerIndex) => {
            gpx += `  <wpt lat="${center.lat.toFixed(6)}" lon="${center.lon.toFixed(6)}">
    <ele>0</ele>
    <name>Center ${centerIndex + 1}</name>
    <desc>Circle center point ${centerIndex + 1}</desc>
    <sym>Flag, Blue</sym>
  </wpt>
`;
        });

        // Generate tracks for each center and radius combination
        centers.forEach((center, centerIndex) => {
            radiiKm.forEach((radiusKm) => {
                const points = generateCircle(center.lat, center.lon, radiusKm, numPoints);

                gpx += `  <trk>
    <name>Center ${centerIndex + 1} - Circle ${radiusKm}km</name>
    <type>Circle</type>
    <trkseg>
`;

                points.forEach((point) => {
                    gpx += `      <trkpt lat="${point.lat.toFixed(6)}" lon="${point.lon.toFixed(6)}">
        <ele>0</ele>
      </trkpt>
`;
                });

                gpx += `    </trkseg>
  </trk>
`;
            });
        });

        gpx += `</gpx>`;

        return gpx;
    }

    // Generate line segment tracks for GPX
    function generateLineSegmentTracks(segments) {
        let gpxTracks = '';

        segments.forEach((segment, segmentIndex) => {
            let endpoint;
            let trackPoints = [];

            if (segment.mode === 'coordinate') {
                endpoint = segment.endpoint;
                trackPoints = [segment.center, endpoint];

                gpxTracks += `  <trk>
    <name>${segment.name || `Line Segment ${segmentIndex + 1}`}</name>
    <type>LineSegment</type>
    <trkseg>
`;
                trackPoints.forEach((point) => {
                    gpxTracks += `      <trkpt lat="${point.lat.toFixed(6)}" lon="${point.lon.toFixed(6)}">
        <ele>0</ele>
      </trkpt>
`;
                });
                gpxTracks += `    </trkseg>
  </trk>
`;
            } else if (segment.mode === 'azimuth') {
                // Calculate endpoint from azimuth and distance
                endpoint = destinationPoint(
                    segment.center.lat,
                    segment.center.lon,
                    segment.distance,
                    segment.azimuth
                );
                // Generate intermediate points for smooth curve
                trackPoints = [];
                const numPoints = 100;
                for (let i = 0; i <= numPoints; i++) {
                    const distance = (i / numPoints) * segment.distance;
                    const point = destinationPoint(segment.center.lat, segment.center.lon, distance, segment.azimuth);
                    trackPoints.push(point);
                }

                gpxTracks += `  <trk>
    <name>${segment.name || `Line Segment ${segmentIndex + 1}`}</name>
    <type>LineSegment</type>
    <trkseg>
`;
                trackPoints.forEach((point) => {
                    gpxTracks += `      <trkpt lat="${point.lat.toFixed(6)}" lon="${point.lon.toFixed(6)}">
        <ele>0</ele>
      </trkpt>
`;
                });
                gpxTracks += `    </trkseg>
  </trk>
`;
            } else if (segment.mode === 'intersection') {
                // Endpoint is already calculated and stored
                endpoint = segment.endpoint;
                trackPoints = [segment.center, endpoint];

                gpxTracks += `  <trk>
    <name>${segment.name || `Line Segment ${segmentIndex + 1}`}</name>
    <type>LineSegment</type>
    <trkseg>
`;
                trackPoints.forEach((point) => {
                    gpxTracks += `      <trkpt lat="${point.lat.toFixed(6)}" lon="${point.lon.toFixed(6)}">
        <ele>0</ele>
      </trkpt>
`;
                });
                gpxTracks += `    </trkseg>
  </trk>
`;
            }
        });

        return gpxTracks;
    }

    // Generate complete GPX with circles and line segments
    function generateCompleteGPX(centers, radiiKm, numPoints, segments, layerPoints = []) {
        const timestamp = new Date().toISOString();
        const radiiDesc =
            radiiKm.length === 1 ? `radius ${radiiKm[0]} km` : `radii ${radiiKm.join(', ')} km`;
        const centersDesc =
            centers.length === 1
                ? `center at ${centers[0].lat}, ${centers[0].lon}`
                : `${centers.length} centers`;

        let descSuffix = '';
        if (segments.length > 0) descSuffix += ` plus ${segments.length} line segment(s)`;
        if (layerPoints.length > 0) descSuffix += ` plus ${layerPoints.length} point(s)`;

        let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX Circle Generator"
     xmlns="http://www.topografix.com/GPX/1/1"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">
  <metadata>
    <name>Circle Tracks and Line Segments</name>
    <desc>Circular tracks with ${centersDesc} and ${radiiDesc}${descSuffix}</desc>
    <time>${timestamp}</time>
  </metadata>
`;

        // Add waypoints for all centers
        centers.forEach((center, centerIndex) => {
            gpx += `  <wpt lat="${center.lat.toFixed(6)}" lon="${center.lon.toFixed(6)}">
    <ele>0</ele>
    <name>Center ${centerIndex + 1}</name>
    <desc>Circle center point ${centerIndex + 1}</desc>
    <sym>Flag, Blue</sym>
  </wpt>
`;
        });

        // Add waypoints for all layer points
        layerPoints.forEach((point) => {
            gpx += `  <wpt lat="${point.coordinates.lat.toFixed(6)}" lon="${point.coordinates.lon.toFixed(6)}">
    <ele>0</ele>
    <name>${point.name}</name>
    <desc>User added point</desc>
    <sym>Flag, Red</sym>
  </wpt>
`;
        });

        // Generate tracks for each center and radius combination
        centers.forEach((center, centerIndex) => {
            radiiKm.forEach((radiusKm) => {
                const points = generateCircle(center.lat, center.lon, radiusKm, numPoints);

                gpx += `  <trk>
    <name>Center ${centerIndex + 1} - Circle ${radiusKm}km</name>
    <type>Circle</type>
    <trkseg>
`;

                points.forEach((point) => {
                    gpx += `      <trkpt lat="${point.lat.toFixed(6)}" lon="${point.lon.toFixed(6)}">
        <ele>0</ele>
      </trkpt>
`;
                });

                gpx += `    </trkseg>
  </trk>
`;
            });
        });

        // Add line segment tracks
        if (segments.length > 0) {
            gpx += generateLineSegmentTracks(segments);
        }

        gpx += `</gpx>`;

        return gpx;
    }

    // Generate timestamp for filename
    function getTimestamp() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const date = String(now.getDate()).padStart(2, '0');
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${date}_${hours}-${minutes}-${seconds}`;
    }

    // ===== GPX FILE UTILITIES =====
    // Download GPX file
    function downloadGPX(content, filename) {
        const blob = new Blob([content], {type: 'application/gpx+xml'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    // Show output message
    function showMessage(message, isError = false) {
        const output = document.getElementById('output');
        const outputMessage = document.getElementById('outputMessage');

        output.classList.remove('success', 'error');
        output.classList.add(isError ? 'error' : 'success');
        output.classList.add('show');
        outputMessage.textContent = message;
    }

    // ===== UI FEEDBACK & NOTIFICATIONS =====
    // Show toast notification
    function showToast(message, isSuccess = true, duration = 3000) {
        // Create toast element
        const toast = document.createElement('div');
        toast.className = `toast ${isSuccess ? 'success' : 'error'}`;

        const icon = isSuccess ? '‚úì' : '‚ö†';
        toast.innerHTML = `
          <div class="toast-icon">${icon}</div>
          <div class="toast-content">${message}</div>
        `;

        // Add to DOM
        document.body.appendChild(toast);

        // Auto remove after duration
        setTimeout(() => {
            toast.classList.add('fade-out');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, duration);
    }

    // ===== MAP VISUALIZATION =====
    let map;
    let mapLayers = [];
    let mapInitialized = false;

    function initMap() {
        if (mapInitialized) return;

        try {
            // Create map centered on default location (Paris)
            map = L.map('map').setView([48.8566, 2.3522], 12);

            // Load IGN Classique map via data.geopf.fr/private/wmts
            console.log('Loading IGN Classique WMTS layer...');
            L.tileLayer(
                'https://data.geopf.fr/private/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE=normal&TILEMATRIXSET=PM&FORMAT=image/jpeg&LAYER=GEOGRAPHICALGRIDSYSTEMS.MAPS&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&apikey=ign_scan_ws',
                {
                    attribution: '&copy; <a href="https://www.ign.fr/">IGN</a>-F/Geoportail',
                    minZoom: 0,
                    maxZoom: 18,
                    crossOrigin: 'anonymous'
                }
            ).addTo(map);

            mapInitialized = true;
            console.log('IGN Scan25 layer loaded');

            // Add right-click context menu to copy coordinates
            const mapContainer = document.getElementById('map');
            if (mapContainer) {
                mapContainer.addEventListener('contextmenu', function(e) {
                    e.preventDefault();

                    // Get map container offset
                    const rect = mapContainer.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Convert pixel position to lat/lng using Leaflet's containerPointToLatLng
                    const latlng = map.containerPointToLatLng(L.point(x, y));

                    const lat = latlng.lat.toFixed(6);
                    const lon = latlng.lng.toFixed(6);
                    const coordinateStr = `${lat}, ${lon}`;

                    console.log('Right-click coordinates:', coordinateStr);

                    // Fill in the coordinate input and open modal
                    document.getElementById('coordinateValue').value = coordinateStr;
                    document.getElementById('coordinateName').value = ''; // Clear name field
                    openModal('savedCoordinatesModal');
                });
            }

            // Invalidate size to ensure map renders correctly
            setTimeout(() => {
                if (map) {
                    map.invalidateSize();
                }
            }, 100);
        } catch (error) {
            console.error('Error initializing map:', error);
        }
    }

    // Clear all map layers (circles and markers)
    function clearMapLayers() {
        if (!map) return;
        mapLayers.forEach((layer) => map.removeLayer(layer));
        mapLayers = [];
    }

    // ===== LAYERS MANAGEMENT =====
    // Data structure for layers
    let layers = {
        circles: [],
        lineSegments: [],
        points: []
    };

    // ===== SAVED COORDINATES MANAGEMENT =====
    // Data structure for saved coordinates
    let savedCoordinates = [];

    // Load saved coordinates from localStorage
    function loadSavedCoordinates() {
        const stored = localStorage.getItem('gpxCircle_savedCoordinates');
        if (stored) {
            try {
                savedCoordinates = JSON.parse(stored);
            } catch (e) {
                console.error('Error loading saved coordinates:', e);
                savedCoordinates = [];
            }
        }
    }

    // Save coordinates to localStorage
    function persistSavedCoordinates() {
        localStorage.setItem('gpxCircle_savedCoordinates', JSON.stringify(savedCoordinates));
    }

    // Add a new saved coordinate
    function addSavedCoordinate(name, latitude, longitude) {
        if (!name || name.trim() === '') {
            alert('Please enter a coordinate name');
            return false;
        }

        const coordinate = {
            id: Date.now(),
            name: name.trim(),
            lat: latitude,
            lon: longitude
        };

        savedCoordinates.push(coordinate);
        persistSavedCoordinates();
        renderSavedCoordinates();
        return true;
    }

    // Delete a saved coordinate
    function deleteSavedCoordinate(id) {
        savedCoordinates = savedCoordinates.filter(coord => coord.id !== id);
        persistSavedCoordinates();
        renderSavedCoordinates();
    }

    // Render saved coordinates list
    function renderSavedCoordinates() {
        const list = document.getElementById('savedCoordinatesList');
        if (savedCoordinates.length === 0) {
            list.innerHTML = '<div class="layers-empty">No saved coordinates yet.</div>';
            return;
        }

        list.innerHTML = savedCoordinates.map(coord => `
          <div class="saved-coordinate-item">
            <div class="saved-coordinate-item-info">
              <div class="saved-coordinate-item-name">${coord.name}</div>
              <div class="saved-coordinate-item-value">${coord.lat}, ${coord.lon}</div>
            </div>
            <div class="saved-coordinate-item-actions">
              <button type="button" class="coordinate-action-btn delete" onclick="deleteSavedCoordinate(${coord.id})">Delete</button>
            </div>
          </div>
        `).join('');
    }

    // Current active coordinate picker
    let activeCoordinatePicker = null;

    // Show coordinate picker dropdown
    function showLoadCoordinateMenu(targetFieldId) {
        // Close any existing dropdown
        if (activeCoordinatePicker) {
            activeCoordinatePicker.remove();
        }

        if (savedCoordinates.length === 0) {
            alert('No saved coordinates yet. Add one using the "Manage Coordinates" button.');
            return;
        }

        // Find the button that was clicked
        const button = event.target.closest('.btn-load-coordinate');
        if (!button) return;

        // Get the button's position
        const rect = button.getBoundingClientRect();

        // Create dropdown container
        const dropdown = document.createElement('div');
        dropdown.className = 'coordinate-picker-dropdown show';

        // Position below button
        let top = rect.bottom + 8;
        let left = rect.left;

        // Adjust if goes off right side
        dropdown.style.position = 'fixed';
        dropdown.style.top = top + 'px';
        dropdown.style.left = left + 'px';

        // Add header
        const header = document.createElement('div');
        header.className = 'coordinate-picker-header';
        header.textContent = 'Select Coordinate';
        dropdown.appendChild(header);

        // Add items list
        const list = document.createElement('div');
        list.className = 'coordinate-picker-list';

        savedCoordinates.forEach(coord => {
            const item = document.createElement('div');
            item.className = 'coordinate-picker-item';
            item.innerHTML = `
            <div class="coordinate-picker-item-name">${coord.name}</div>
            <div class="coordinate-picker-item-value">${coord.lat}, ${coord.lon}</div>
          `;
            item.onclick = () => {
                const targetInput = document.getElementById(targetFieldId);
                if (targetInput) {
                    targetInput.value = `${coord.lat}, ${coord.lon}`;
                    targetInput.focus();
                }
                dropdown.remove();
                activeCoordinatePicker = null;
            };
            list.appendChild(item);
        });

        dropdown.appendChild(list);

        // Add to document
        document.body.appendChild(dropdown);
        activeCoordinatePicker = dropdown;

        // Close dropdown when clicking outside
        const closeDropdown = (e) => {
            if (!dropdown.contains(e.target) && !button.contains(e.target)) {
                dropdown.remove();
                activeCoordinatePicker = null;
                document.removeEventListener('click', closeDropdown);
                document.removeEventListener('keydown', closeOnEscape);
            }
        };

        // Close dropdown on Escape
        const closeOnEscape = (e) => {
            if (e.key === 'Escape') {
                dropdown.remove();
                activeCoordinatePicker = null;
                document.removeEventListener('click', closeDropdown);
                document.removeEventListener('keydown', closeOnEscape);
            }
        };

        setTimeout(() => {
            document.addEventListener('click', closeDropdown);
            document.addEventListener('keydown', closeOnEscape);
        }, 0);
    }

    // Load a coordinate to the active input field or target field
    function loadCoordinateToField(lat, lon) {
        const activeInput = document.activeElement;

        // Check if focused element is a coordinate input
        if (activeInput && activeInput.id && (
            activeInput.id === 'circleCenter' ||
            activeInput.id === 'lineSegmentCenter' ||
            activeInput.id === 'lineSegmentEndpoint' ||
            activeInput.id === 'lineSegmentIntersectionPoint' ||
            activeInput.id === 'pointCoordinates'
        )) {
            activeInput.value = `${lat}, ${lon}`;
            activeInput.focus();
            return;
        }

        // If no specific input is focused, show a dialog to select target
        showCoordinateLoadDialog(lat, lon);
    }

    // Show dialog to select which input to load the coordinate into
    function showCoordinateLoadDialog(lat, lon) {
        const inputOptions = [
            {id: 'circleCenter', label: 'Circle Center'},
            {id: 'lineSegmentCenter', label: 'Line Segment Center'},
            {id: 'lineSegmentEndpoint', label: 'Line Segment Endpoint'},
            {id: 'lineSegmentIntersectionPoint', label: 'Intersection Point'},
            {id: 'pointCoordinates', label: 'Point Coordinates'}
        ];

        const availableInputs = inputOptions.filter(opt => {
            const input = document.getElementById(opt.id);
            return input && !input.hidden && input.style.display !== 'none';
        });

        if (availableInputs.length === 0) {
            alert('No coordinate input field available. Please open a form first.');
            return;
        }

        if (availableInputs.length === 1) {
            document.getElementById(availableInputs[0].id).value = `${lat}, ${lon}`;
            return;
        }

        // Create a simple selection UI
        let message = 'Select where to load this coordinate:\n\n';
        availableInputs.forEach((opt, idx) => {
            message += `${idx + 1}. ${opt.label}\n`;
        });

        const choice = prompt(message + '\nEnter the number (1-' + availableInputs.length + '):');
        if (choice) {
            const selectedIndex = parseInt(choice) - 1;
            if (selectedIndex >= 0 && selectedIndex < availableInputs.length) {
                const selectedInput = document.getElementById(availableInputs[selectedIndex].id);
                selectedInput.value = `${lat}, ${lon}`;
                selectedInput.focus();
            }
        }
    }

    // Add a new circle to layers
    function addCircleLayer(name, center, radius) {
        const circle = {
            id: Date.now(),
            name: name,
            center: center,
            radius: radius
        };
        layers.circles.push(circle);
        updateLayersPanel();
        updateMapPreview();
        return circle.id;
    }

    // Add a new line segment to layers
    function addLineSegmentLayer(name, center, mode, endpoint, azimuth, distance, intersectionPoint, intersectionDistance) {
        const segment = {
            id: Date.now(),
            name: name,
            center: center,
            mode: mode,
            endpoint: endpoint,
            azimuth: azimuth,
            distance: distance,
            intersectionPoint: intersectionPoint,
            intersectionDistance: intersectionDistance
        };
        layers.lineSegments.push(segment);
        updateLayersPanel();
        updateMapPreview();
        return segment.id;
    }

    // Add a new point to layers
    function addPointLayer(name, coordinates) {
        const point = {
            id: Date.now(),
            name: name,
            coordinates: coordinates
        };
        layers.points.push(point);
        updateLayersPanel();
        updateMapPreview();
        return point.id;
    }

    // Remove a layer by type and id
    function removeLayer(type, id) {
        if (type === 'circle') {
            layers.circles = layers.circles.filter(c => c.id !== id);
        } else if (type === 'lineSegment') {
            layers.lineSegments = layers.lineSegments.filter(s => s.id !== id);
        } else if (type === 'point') {
            layers.points = layers.points.filter(p => p.id !== id);
        }
        updateLayersPanel();
        updateMapPreview();
    }

    // Update the layers panel UI
    function updateLayersPanel() {
        const layersPanel = document.getElementById('layersPanel');

        if (layers.circles.length === 0 && layers.lineSegments.length === 0 && layers.points.length === 0) {
            layersPanel.innerHTML = '<div class="layers-empty-state">No elements added yet. Use the buttons above to add circles, line segments, or points.</div>';
            return;
        }

        let html = '';

        // Add circles
        layers.circles.forEach(circle => {
            html += `
            <div class="layer-item" data-type="circle" data-id="${circle.id}">
              <div class="layer-item-info">
                <div class="layer-item-name">üîµ ${escapeHtml(circle.name)}</div>
                <div class="layer-item-type">Circle ‚Ä¢ ${circle.radius} km radius</div>
              </div>
              <div class="layer-item-actions">
                <button type="button" class="layer-action-btn" onclick="editCircleLayer(${circle.id})">Edit</button>
                <button type="button" class="layer-action-btn delete" onclick="removeLayer('circle', ${circle.id})">Delete</button>
              </div>
            </div>
          `;
        });

        // Add line segments
        layers.lineSegments.forEach(segment => {
            let modeLabel = 'Endpoint';
            if (segment.mode === 'azimuth') {
                modeLabel = 'Azimuth';
            } else if (segment.mode === 'intersection') {
                modeLabel = 'Intersection';
            }
            html += `
            <div class="layer-item" data-type="lineSegment" data-id="${segment.id}">
              <div class="layer-item-info">
                <div class="layer-item-name">‚ûñ ${escapeHtml(segment.name)}</div>
                <div class="layer-item-type">Line Segment ‚Ä¢ ${modeLabel}</div>
              </div>
              <div class="layer-item-actions">
                <button type="button" class="layer-action-btn" onclick="editLineSegmentLayer(${segment.id})">Edit</button>
                <button type="button" class="layer-action-btn delete" onclick="removeLayer('lineSegment', ${segment.id})">Delete</button>
              </div>
            </div>
          `;
        });

        // Add points
        layers.points.forEach(point => {
            html += `
            <div class="layer-item" data-type="point" data-id="${point.id}">
              <div class="layer-item-info">
                <div class="layer-item-name">üìç ${escapeHtml(point.name)}</div>
                <div class="layer-item-type">Point ‚Ä¢ ${point.coordinates.lat.toFixed(4)}, ${point.coordinates.lon.toFixed(4)}</div>
              </div>
              <div class="layer-item-actions">
                <button type="button" class="layer-action-btn" onclick="editPointLayer(${point.id})">Edit</button>
                <button type="button" class="layer-action-btn delete" onclick="removeLayer('point', ${point.id})">Delete</button>
              </div>
            </div>
          `;
        });

        layersPanel.innerHTML = html;
    }

    // Edit circle layer
    function editCircleLayer(id) {
        const circle = layers.circles.find(c => c.id === id);
        if (!circle) return;

        // Populate modal with circle data
        document.getElementById('circleName').value = circle.name;
        document.getElementById('circleCenter').value = `${circle.center.lat}, ${circle.center.lon}`;
        document.getElementById('circleRadius').value = circle.radius;

        // Change modal title and button text
        document.getElementById('circleModalTitle').textContent = 'Edit Circle';
        const submitBtn = document.querySelector('#circleForm .modal-btn-primary');
        submitBtn.textContent = 'Update Circle';

        // Store the id for update
        document.getElementById('circleForm').dataset.editId = id;

        // Show modal
        openModal('circleModal');
    }

    // Edit line segment layer
    function editLineSegmentLayer(id) {
        const segment = layers.lineSegments.find(s => s.id === id);
        if (!segment) return;

        // Populate modal with segment data
        document.getElementById('lineSegmentName').value = segment.name;
        document.getElementById('lineSegmentCenter').value = `${segment.center.lat}, ${segment.center.lon}`;
        document.getElementById('lineSegmentMode').value = segment.mode;

        // Show/hide appropriate fields based on mode
        updateLineSegmentModeFields(segment.mode);

        if (segment.mode === 'coordinate') {
            document.getElementById('lineSegmentEndpoint').value = `${segment.endpoint.lat}, ${segment.endpoint.lon}`;
        } else if (segment.mode === 'azimuth') {
            document.getElementById('lineSegmentAzimuth').value = segment.azimuth;
            document.getElementById('lineSegmentDistance').value = segment.distance;
        } else if (segment.mode === 'intersection') {
            document.getElementById('lineSegmentIntersectionPoint').value = `${segment.intersectionPoint.lat}, ${segment.intersectionPoint.lon}`;
            document.getElementById('lineSegmentIntersectionDistance').value = segment.intersectionDistance;
        }

        // Change modal title and button text
        document.getElementById('lineSegmentModalTitle').textContent = 'Edit Line Segment';
        const submitBtn = document.querySelector('#lineSegmentForm .modal-btn-primary');
        submitBtn.textContent = 'Update Line Segment';

        // Store the id for update
        document.getElementById('lineSegmentForm').dataset.editId = id;

        // Show modal
        openModal('lineSegmentModal');
    }

    // Edit point layer
    function editPointLayer(id) {
        const point = layers.points.find(p => p.id === id);
        if (!point) return;

        // Populate modal with point data
        document.getElementById('pointName').value = point.name;
        document.getElementById('pointCoordinates').value = `${point.coordinates.lat}, ${point.coordinates.lon}`;

        // Change modal title and button text
        document.getElementById('pointModalTitle').textContent = 'Edit Point';
        const submitBtn = document.querySelector('#pointForm .modal-btn-primary');
        submitBtn.textContent = 'Update Point';

        // Store the id for update
        document.getElementById('pointForm').dataset.editId = id;

        // Show modal
        openModal('pointModal');
    }

    // Helper to update line segment mode fields visibility
    function updateLineSegmentModeFields(mode) {
        const coordinateMode = document.getElementById('coordinateMode');
        const azimuthMode = document.querySelectorAll('.azimuth-mode');
        const intersectionMode = document.querySelectorAll('.intersection-mode');

        switch (mode) {
            case 'coordinate':
                show(coordinateMode);
                hideAll(azimuthMode);
                hideAll(intersectionMode);
                break;
            case 'azimuth':
                hide(coordinateMode);
                showAll(azimuthMode);
                hideAll(intersectionMode);
                break;
            case 'intersection':
                hide(coordinateMode);
                hideAll(azimuthMode);
                showAll(intersectionMode);
                break;
        }
    }

    // HTML escape helper
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // ===== UI HELPERS: MODALS & VISIBILITY =====
    // Open/close modal by element id
    function openModal(id) {
        const el = document.getElementById(id);
        if (el) el.classList.add('show');
    }

    function closeModal(id) {
        const el = document.getElementById(id);
        if (el) el.classList.remove('show');
    }

    // Show/hide single element and lists
    function show(el) {
        if (!el) return;
        el.style.display = 'block';
    }

    function hide(el) {
        if (!el) return;
        el.style.display = 'none';
    }

    function showAll(list) {
        if (!list) return;
        list.forEach(show);
    }

    function hideAll(list) {
        if (!list) return;
        list.forEach(hide);
    }

    // ===== PROJECT MANAGEMENT: CONSTANTS & HELPER FUNCTIONS =====
    const PROJECTS_STORAGE_KEY = 'gpxCircleProjects';

    // Get all saved projects from localStorage
    function getAllProjects() {
        const data = localStorage.getItem(PROJECTS_STORAGE_KEY);
        return data ? JSON.parse(data) : [];
    }

    // Save all projects to localStorage
    function saveProjectsToStorage(projects) {
        localStorage.setItem(PROJECTS_STORAGE_KEY, JSON.stringify(projects));
    }

    // Collect current form data
    function getCurrentFormData() {
        return {
            layers: layers
        };
    }

    // Load form data from saved project
    function loadFormData(data) {
        // Load layers
        if (data.layers) {
            layers = JSON.parse(JSON.stringify(data.layers)); // Deep copy
            updateLayersPanel();
            updateMapPreview();
        }
    }

    // ===== INITIALIZATION =====
    // Single consolidated initialization on page load
    document.addEventListener('DOMContentLoaded', function () {
        // Initialize map
        setTimeout(initMap, 100);

        // Setup project search
        const projectSearch = document.getElementById('projectSearch');
        const projectDropdown = document.getElementById('projectDropdown');
        const saveProjectBtn = document.getElementById('saveProjectBtn');

        if (projectSearch && projectDropdown) {
            // Show dropdown on focus
            projectSearch.addEventListener('focus', function () {
                refreshProjectsDropdown();
                projectDropdown.classList.add('show');
            });

            // Filter on input
            projectSearch.addEventListener('input', function (e) {
                if (e.target.value.trim().length === 0) {
                    refreshProjectsDropdown();
                } else {
                    filterProjects(e.target.value);
                }
                projectDropdown.classList.add('show');
            });

            // Hide dropdown when clicking outside
            document.addEventListener('click', function (e) {
                if (!e.target.closest('.project-search-wrapper')) {
                    projectDropdown.classList.remove('show');
                }
            });
        }

        // Setup save project button (toggle dropdown)
        const dropdownMenu = document.getElementById('saveDropdownMenu');
        if (saveProjectBtn) {
            saveProjectBtn.addEventListener('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                dropdownMenu.classList.toggle('show');
            });
        }

        // Setup dropdown menu items
        const saveProjectOption = document.getElementById('saveProjectOption');
        const exportDataOption = document.getElementById('exportDataOption');
        const importDataOption = document.getElementById('importDataOption');

        if (saveProjectOption) {
            saveProjectOption.addEventListener('click', function (e) {
                e.preventDefault();
                dropdownMenu.classList.remove('show');

                // Check if there are any elements added
                if (layers.circles.length === 0 && layers.lineSegments.length === 0 && layers.points.length === 0) {
                    showMessage('Please add at least one element (circle, line segment, or point)', true);
                    return;
                }

                // Generate default project name
                const timestamp = getTimestamp();
                const circlesCount = layers.circles.length;
                const segmentsCount = layers.lineSegments.length;
                const pointsCount = layers.points.length;

                let defaultProjectName = `${timestamp}`;
                if (circlesCount > 0) defaultProjectName += `_${circlesCount}circles`;
                if (segmentsCount > 0) defaultProjectName += `_${segmentsCount}segments`;
                if (pointsCount > 0) defaultProjectName += `_${pointsCount}points`;

                // Show filename modal for project name
                document.getElementById('filenameInput').value = defaultProjectName;
                document.getElementById('filenameModalTitle').textContent = 'Save Project';
                document.getElementById('confirmFilenameBtn').textContent = 'Save';
                document.getElementById('filenameForm').dataset.action = 'save';
                openModal('filenameModal');
            });
        }

        if (exportDataOption) {
            exportDataOption.addEventListener('click', function (e) {
                e.preventDefault();
                dropdownMenu.classList.remove('show');
                exportDataAsJSON();
                showMessage('Data exported successfully!');
            });
        }

        if (importDataOption) {
            importDataOption.addEventListener('click', function (e) {
                e.preventDefault();
                dropdownMenu.classList.remove('show');
                document.getElementById('importFileInput').click();
            });
        }

        // Handle file import
        const importFileInput = document.getElementById('importFileInput');
        if (importFileInput) {
            importFileInput.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file) {
                    importDataFromJSON(file);
                    // Reset input
                    e.target.value = '';
                }
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.dropdown-menu-container')) {
                dropdownMenu.classList.remove('show');
            }
        });

        // Load projects on page load
        refreshProjectsDropdown();

        // ===== LAYERS MODAL EVENT LISTENERS =====
        // Add Circle button
        const addCircleBtn = document.getElementById('addCircleBtn');
        if (addCircleBtn) {
            addCircleBtn.addEventListener('click', function (e) {
                e.preventDefault();
                // Reset form for new circle
                document.getElementById('circleForm').reset();
                document.getElementById('circleForm').removeAttribute('data-editId');
                document.getElementById('circleModalTitle').textContent = 'Add Circle';
                document.querySelector('#circleForm .modal-btn-primary').textContent = 'Add Circle';
                openModal('circleModal');
            });
        }

        // Cancel Circle button
        const cancelCircleBtn = document.getElementById('cancelCircleBtn');
        if (cancelCircleBtn) {
            cancelCircleBtn.addEventListener('click', function () {
                closeModal('circleModal');
            });
        }

        // Circle Form submission
        const circleForm = document.getElementById('circleForm');
        if (circleForm) {
            circleForm.addEventListener('submit', function (e) {
                e.preventDefault();
                let name = document.getElementById('circleName').value.trim();
                const centerStr = document.getElementById('circleCenter').value.trim();
                const radiusStr = document.getElementById('circleRadius').value.trim();

                // Parse center coordinates
                const centerParts = centerStr.split(',').map(s => parseFloat(s.trim()));
                if (centerParts.length !== 2 || isNaN(centerParts[0]) || isNaN(centerParts[1])) {
                    alert('Invalid center coordinates. Please enter as: lat, lon');
                    return;
                }

                const radius = parseFloat(radiusStr);
                if (isNaN(radius) || radius <= 0) {
                    alert('Invalid radius. Please enter a positive number.');
                    return;
                }

                // Autogenerate name if empty
                if (!name) {
                    name = autogenerateName('circle');
                }

                const center = {lat: centerParts[0], lon: centerParts[1]};
                const editId = circleForm.dataset.editId;

                if (editId) {
                    // Update existing circle
                    const circle = layers.circles.find(c => c.id === parseInt(editId));
                    if (circle) {
                        circle.name = name;
                        circle.center = center;
                        circle.radius = radius;
                    }
                } else {
                    // Add new circle
                    addCircleLayer(name, center, radius);
                }

                updateLayersPanel();
                updateMapPreview();
                closeModal('circleModal');
                circleForm.reset();
                circleForm.removeAttribute('data-editId');
            });

            // Allow form submission by pressing Enter
            circleForm.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    circleForm.dispatchEvent(new Event('submit'));
                }
            });
        }

        // Add Line Segment button
        const addLineSegmentBtn = document.getElementById('addLineSegmentBtn');
        if (addLineSegmentBtn) {
            addLineSegmentBtn.addEventListener('click', function (e) {
                e.preventDefault();
                // Reset form for new line segment
                document.getElementById('lineSegmentForm').reset();
                document.getElementById('lineSegmentForm').removeAttribute('data-editId');
                document.getElementById('lineSegmentModalTitle').textContent = 'Add Line Segment';
                document.querySelector('#lineSegmentForm .modal-btn-primary').textContent = 'Add Line Segment';
                document.getElementById('lineSegmentMode').value = 'coordinate';
                updateLineSegmentModeFields('coordinate');
                openModal('lineSegmentModal');
            });
        }

        // Cancel Line Segment button
        const cancelLineSegmentBtn = document.getElementById('cancelLineSegmentBtn');
        if (cancelLineSegmentBtn) {
            cancelLineSegmentBtn.addEventListener('click', function () {
                closeModal('lineSegmentModal');
            });
        }

        // Line Segment Mode change
        const lineSegmentMode = document.getElementById('lineSegmentMode');
        if (lineSegmentMode) {
            lineSegmentMode.addEventListener('change', function () {
                updateLineSegmentModeFields(this.value);
            });
        }

        // Line Segment Form submission
        const lineSegmentForm = document.getElementById('lineSegmentForm');
        if (lineSegmentForm) {
            lineSegmentForm.addEventListener('submit', function (e) {
                e.preventDefault();
                let name = document.getElementById('lineSegmentName').value.trim();
                const centerStr = document.getElementById('lineSegmentCenter').value.trim();
                const mode = document.getElementById('lineSegmentMode').value;

                // Parse center coordinates
                const centerParts = centerStr.split(',').map(s => parseFloat(s.trim()));
                if (centerParts.length !== 2 || isNaN(centerParts[0]) || isNaN(centerParts[1])) {
                    alert('Invalid center coordinates. Please enter as: lat, lon');
                    return;
                }

                const center = {lat: centerParts[0], lon: centerParts[1]};
                let endpoint, azimuth, distance, intersectionPoint, intersectionDistance;

                if (mode === 'coordinate') {
                    const endpointStr = document.getElementById('lineSegmentEndpoint').value.trim();
                    const endpointParts = endpointStr.split(',').map(s => parseFloat(s.trim()));
                    if (endpointParts.length !== 2 || isNaN(endpointParts[0]) || isNaN(endpointParts[1])) {
                        alert('Invalid endpoint coordinates. Please enter as: lat, lon');
                        return;
                    }
                    endpoint = {lat: endpointParts[0], lon: endpointParts[1]};
                } else if (mode === 'azimuth') {
                    azimuth = parseFloat(document.getElementById('lineSegmentAzimuth').value);
                    distance = parseFloat(document.getElementById('lineSegmentDistance').value);

                    if (isNaN(azimuth) || azimuth < 0 || azimuth >= 360) {
                        alert('Invalid azimuth. Please enter a number between 0 and 359.');
                        return;
                    }

                    if (isNaN(distance) || distance <= 0) {
                        alert('Invalid distance. Please enter a positive number.');
                        return;
                    }
                } else if (mode === 'intersection') {
                    const intersectionStr = document.getElementById('lineSegmentIntersectionPoint').value.trim();
                    const intersectionParts = intersectionStr.split(',').map(s => parseFloat(s.trim()));
                    if (intersectionParts.length !== 2 || isNaN(intersectionParts[0]) || isNaN(intersectionParts[1])) {
                        alert('Invalid intersection point coordinates. Please enter as: lat, lon');
                        return;
                    }
                    intersectionPoint = {lat: intersectionParts[0], lon: intersectionParts[1]};

                    intersectionDistance = parseFloat(document.getElementById('lineSegmentIntersectionDistance').value);
                    if (isNaN(intersectionDistance) || intersectionDistance <= 0) {
                        alert('Invalid distance. Please enter a positive number.');
                        return;
                    }

                    // Validate that the specified distance reaches at least up to the intersection point
                    const minDist = calculateDistance(center.lat, center.lon, intersectionPoint.lat, intersectionPoint.lon);
                    if (intersectionDistance + 1e-9 < minDist) {
                        alert(`Distance too short to pass through the intersection point. Minimum required: ${minDist.toFixed(3)} km`);
                        return;
                    }

                    // Calculate endpoint using the intersection point and distance
                    endpoint = endpointFromIntersection(center.lat, center.lon, intersectionPoint.lat, intersectionPoint.lon, intersectionDistance);
                }

                // Autogenerate name if empty
                if (!name) {
                    if (mode === 'coordinate') {
                        const startName = getSavedCoordinateName(center.lat, center.lon);
                        const endName = getSavedCoordinateName(endpoint.lat, endpoint.lon);
                        if (startName && endName) {
                            name = `${startName} => ${endName}`;
                        } else {
                            name = autogenerateName('lineSegment', {mode});
                        }
                    } else {
                        name = autogenerateName('lineSegment', {mode});
                    }
                }

                const editId = lineSegmentForm.dataset.editId;

                if (editId) {
                    // Update existing line segment
                    const segment = layers.lineSegments.find(s => s.id === parseInt(editId));
                    if (segment) {
                        segment.name = name;
                        segment.center = center;
                        segment.mode = mode;
                        segment.endpoint = endpoint;
                        segment.azimuth = azimuth;
                        segment.distance = distance;
                        segment.intersectionPoint = intersectionPoint;
                        segment.intersectionDistance = intersectionDistance;
                    }
                } else {
                    // Add new line segment
                    addLineSegmentLayer(name, center, mode, endpoint, azimuth, distance, intersectionPoint, intersectionDistance);
                }

                updateLayersPanel();
                updateMapPreview();
                closeModal('lineSegmentModal');
                lineSegmentForm.reset();
                lineSegmentForm.removeAttribute('data-editId');
            });

            // Allow form submission by pressing Enter
            lineSegmentForm.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    lineSegmentForm.dispatchEvent(new Event('submit'));
                }
            });
        }

        // Add Point button
        const addPointBtn = document.getElementById('addPointBtn');
        if (addPointBtn) {
            addPointBtn.addEventListener('click', function (e) {
                e.preventDefault();
                // Reset form for new point
                document.getElementById('pointForm').reset();
                document.getElementById('pointForm').removeAttribute('data-editId');
                document.getElementById('pointModalTitle').textContent = 'Add Point';
                document.querySelector('#pointForm .modal-btn-primary').textContent = 'Add Point';
                openModal('pointModal');
            });
        }

        // Cancel Point button
        const cancelPointBtn = document.getElementById('cancelPointBtn');
        if (cancelPointBtn) {
            cancelPointBtn.addEventListener('click', function () {
                closeModal('pointModal');
            });
        }

        // Point Form submission
        const pointForm = document.getElementById('pointForm');
        if (pointForm) {
            pointForm.addEventListener('submit', function (e) {
                e.preventDefault();
                let name = document.getElementById('pointName').value.trim();
                const coordinatesStr = document.getElementById('pointCoordinates').value.trim();

                // Parse coordinates
                const coordinateParts = coordinatesStr.split(',').map(s => parseFloat(s.trim()));
                if (coordinateParts.length !== 2 || isNaN(coordinateParts[0]) || isNaN(coordinateParts[1])) {
                    alert('Invalid coordinates. Please enter as: lat, lon');
                    return;
                }

                const coordinates = {lat: coordinateParts[0], lon: coordinateParts[1]};

                // Autogenerate name if empty
                if (!name) {
                    // Try to use saved coordinate name if available
                    const savedName = getSavedCoordinateName(coordinates.lat, coordinates.lon);
                    if (savedName) {
                        name = savedName;
                    } else {
                        name = autogenerateName('point');
                    }
                }

                const editId = pointForm.dataset.editId;

                if (editId) {
                    // Update existing point
                    const point = layers.points.find(p => p.id === parseInt(editId));
                    if (point) {
                        point.name = name;
                        point.coordinates = coordinates;
                    }
                } else {
                    // Add new point
                    addPointLayer(name, coordinates);
                }

                updateLayersPanel();
                updateMapPreview();
                closeModal('pointModal');
                pointForm.reset();
                pointForm.removeAttribute('data-editId');
            });

            // Allow form submission by pressing Enter
            pointForm.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    pointForm.dispatchEvent(new Event('submit'));
                }
            });
        }

        // ===== SAVED COORDINATES EVENT LISTENERS =====
        const saveCoordinateBtn = document.getElementById('saveCoordinateBtn');
        if (saveCoordinateBtn) {
            saveCoordinateBtn.addEventListener('click', function (e) {
                e.preventDefault();
                const name = document.getElementById('coordinateName').value.trim();
                const coordinateStr = document.getElementById('coordinateValue').value.trim();

                // Parse coordinates
                const coordinateParts = coordinateStr.split(',').map(s => parseFloat(s.trim()));
                if (coordinateParts.length !== 2 || isNaN(coordinateParts[0]) || isNaN(coordinateParts[1])) {
                    alert('Invalid coordinates. Please enter as: lat, lon');
                    return;
                }

                const lat = coordinateParts[0];
                const lon = coordinateParts[1];

                // Validate latitude and longitude
                if (lat < -90 || lat > 90) {
                    alert('Invalid latitude. Must be between -90 and 90.');
                    return;
                }
                if (lon < -180 || lon > 180) {
                    alert('Invalid longitude. Must be between -180 and 180.');
                    return;
                }

                if (addSavedCoordinate(name, lat, lon)) {
                    // Clear the form
                    document.getElementById('coordinateName').value = '';
                    document.getElementById('coordinateValue').value = '';
                    document.getElementById('coordinateName').focus();
                }
            });
        }

        // Allow saved coordinates form submission by pressing Enter
        const coordinateNameInput = document.getElementById('coordinateName');
        const coordinateValueInput = document.getElementById('coordinateValue');
        if (coordinateNameInput) {
            coordinateNameInput.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveCoordinateBtn.click();
                }
            });
        }
        if (coordinateValueInput) {
            coordinateValueInput.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveCoordinateBtn.click();
                }
            });
        }

        // ===== SAVED COORDINATES MODAL EVENT LISTENERS =====
        const manageSavedCoordinatesBtn = document.getElementById('manageSavedCoordinatesBtn');
        if (manageSavedCoordinatesBtn) {
            manageSavedCoordinatesBtn.addEventListener('click', function () {
                openModal('savedCoordinatesModal');
            });
        }

        const cancelSavedCoordinatesBtn = document.getElementById('cancelSavedCoordinatesBtn');
        if (cancelSavedCoordinatesBtn) {
            cancelSavedCoordinatesBtn.addEventListener('click', function () {
                closeModal('savedCoordinatesModal');
            });
        }

        // ===== FILENAME MODAL EVENT LISTENERS =====
        const cancelFilenameBtn = document.getElementById('cancelFilenameBtn');
        if (cancelFilenameBtn) {
            cancelFilenameBtn.addEventListener('click', function () {
                closeModal('filenameModal');
            });
        }

        // Close modals on ESC key press
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const circleModal = document.getElementById('circleModal');
                const lineSegmentModal = document.getElementById('lineSegmentModal');
                const pointModal = document.getElementById('pointModal');
                const filenameModal = document.getElementById('filenameModal');
                const savedCoordinatesModal = document.getElementById('savedCoordinatesModal');

                if (circleModal && circleModal.classList.contains('show')) {
                    closeModal('circleModal');
                } else if (lineSegmentModal && lineSegmentModal.classList.contains('show')) {
                    closeModal('lineSegmentModal');
                } else if (pointModal && pointModal.classList.contains('show')) {
                    closeModal('pointModal');
                } else if (savedCoordinatesModal && savedCoordinatesModal.classList.contains('show')) {
                    closeModal('savedCoordinatesModal');
                } else if (filenameModal && filenameModal.classList.contains('show')) {
                    closeModal('filenameModal');
                }
            }
        });

        const filenameForm = document.getElementById('filenameForm');
        if (filenameForm) {
            filenameForm.addEventListener('submit', function (e) {
                e.preventDefault();
                const filename = document.getElementById('filenameInput').value.trim();
                const action = filenameForm.dataset.action;

                if (!filename) {
                    alert('Please enter a filename');
                    return;
                }

                if (action === 'download') {
                    // Download GPX
                    let finalFilename = filename;
                    if (!finalFilename.endsWith('.gpx')) {
                        finalFilename += '.gpx';
                    }

                    downloadGPX(pendingGPXData.content, finalFilename);

                    const circleInfo =
                        pendingGPXData.radii.length === 1
                            ? `${pendingGPXData.circlesCount} circle(s) with ${pendingGPXData.points} points each and ${pendingGPXData.radii[0]} km radius.`
                            : `${pendingGPXData.circlesCount} circle(s) with ${pendingGPXData.points} points each and radii: ${pendingGPXData.radii.join(', ')} km.`;
                    const segmentInfo =
                        pendingGPXData.segmentsCount > 0 ? ` Plus ${pendingGPXData.segmentsCount} line segment(s).` : '';

                    showMessage(
                        `GPX file generated successfully! ${circleInfo}${segmentInfo} File downloaded as ${finalFilename}`,
                        false
                    );

                    closeModal('filenameModal');
                } else if (action === 'save') {
                    // Save project
                    let projectName = filename;
                    if (projectName.endsWith('.gpx')) {
                        projectName = projectName.slice(0, -4);
                    }

                    saveProject(projectName);
                    closeModal('filenameModal');
                }
            });

            // Allow form submission by pressing Enter
            filenameForm.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    filenameForm.dispatchEvent(new Event('submit'));
                }
            });
        }

        // Close modals when clicking outside of them
        document.addEventListener('click', function (e) {
            const circleModal = document.getElementById('circleModal');
            if (e.target === circleModal) {
                closeModal('circleModal');
            }

            const lineSegmentModal = document.getElementById('lineSegmentModal');
            if (e.target === lineSegmentModal) {
                closeModal('lineSegmentModal');
            }

            const pointModal = document.getElementById('pointModal');
            if (e.target === pointModal) {
                closeModal('pointModal');
            }

            const filenameModal = document.getElementById('filenameModal');
            if (e.target === filenameModal) {
                closeModal('filenameModal');
            }

            const savedCoordinatesModal = document.getElementById('savedCoordinatesModal');
            if (e.target === savedCoordinatesModal) {
                closeModal('savedCoordinatesModal');
            }
        });
    });

    // ===== LINE SEGMENTS MANAGEMENT =====
    // Parse multiple coordinate pairs (numbers taken 2 by 2)
    function parseMultipleCoordinates(input) {
        // Split by comma and trim each part
        const parts = input.split(',').map((part) => part.trim());

        // If odd number of values, return error
        if (parts.length % 2 !== 0) {
            return {error: 'Please enter coordinates as pairs: lat, lon, lat, lon, ...'};
        }

        const centers = [];

        // Process numbers 2 by 2
        for (let i = 0; i < parts.length; i += 2) {
            const lat = parseFloat(parts[i]);
            const lon = parseFloat(parts[i + 1]);

            // Validate latitude and longitude
            if (isNaN(lat) || lat < -90 || lat > 90) {
                return {
                    error: `Invalid latitude at position ${i + 1}: ${parts[i]} (must be between -90 and 90)`,
                };
            }

            if (isNaN(lon) || lon < -180 || lon > 180) {
                return {
                    error: `Invalid longitude at position ${i + 2}: ${parts[i + 1]} (must be between -180 and 180)`,
                };
            }

            centers.push({lat, lon});
        }

        if (centers.length === 0) {
            return {error: 'Please enter at least one center coordinate pair'};
        }

        return {centers};
    }

    // Track whether user has manually edited the filename
    let filenameManuallyEdited = false;

    // Generate suggested filename
    function generateSuggestedFilename() {
        const coordsInput = document.getElementById('coordinates').value.trim();
        const radiusInput = document.getElementById('radius').value.trim();

        // Parse coordinates and radii to count them
        const coordsResult = parseMultipleCoordinates(coordsInput);
        if (coordsResult.error) {
            return '';
        }

        let processedInput = radiusInput;
        processedInput = processedInput.replace(/(\d),(\d)/g, '$1.$2');

        const radiusParts = processedInput
            .split(/[\s,]+/)
            .map((part) => part.trim())
            .filter((part) => part.length > 0);

        const radii = radiusParts.map((part) => {
            const value = parseFloat(part);
            if (isNaN(value) || value <= 0) {
                return null;
            }
            return Math.round(value * 100) / 100;
        });

        if (radii.some((r) => r === null)) {
            return '';
        }

        const timestamp = getTimestamp();
        const radiiStr = radii.length === 1 ? `${radii[0]}km` : `${radii.join('_')}km`;
        const centersCount = coordsResult.centers.length;

        let lineSegmentsCount = 0;
        try {
            lineSegmentsCount = parseLineSegments().length;
        } catch (e) {
            // Ignore
        }

        const filename =
            lineSegmentsCount > 0
                ? `${timestamp}_circles_${centersCount}centers_${lineSegmentsCount}segments_${radiiStr}.gpx`
                : `${timestamp}_circles_${centersCount}centers_${radiiStr}.gpx`;

        return filename;
    }

    // Autogenerate element name based on context
    function autogenerateName(type, context = {}) {
        if (type === 'circle') {
            const count = layers.circles.length + 1;
            return `Circle ${count}`;
        } else if (type === 'lineSegment') {
            // For line segments with saved coordinates
            if (context.mode === 'coordinate' && context.startName && context.endName) {
                return `${context.startName} => ${context.endName}`;
            }
            // Generic naming
            const count = layers.lineSegments.length + 1;
            return `Line ${count}`;
        } else if (type === 'point') {
            const count = layers.points.length + 1;
            return `Point ${count}`;
        }
        return '';
    }

    // Get saved coordinate name by coordinates
    function getSavedCoordinateName(lat, lon) {
        const coord = savedCoordinates.find(c =>
            Math.abs(c.lat - lat) < 0.0001 && Math.abs(c.lon - lon) < 0.0001
        );
        return coord ? coord.name : null;
    }

    // Export all data as JSON
    function exportDataAsJSON() {
        const exportData = {
            version: '1.0',
            timestamp: new Date().toISOString(),
            circles: layers.circles,
            lineSegments: layers.lineSegments,
            points: layers.points,
            savedCoordinates: savedCoordinates
        };

        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], {type: 'application/json'});
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `gpx-circle-export-${getTimestamp()}.json`;
        link.click();
        URL.revokeObjectURL(url);
    }

    // Import data from JSON
    function importDataFromJSON(file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importData = JSON.parse(e.target.result);

                if (!importData.version) {
                    alert('Invalid export file format');
                    return;
                }

                // Import circles
                if (importData.circles && Array.isArray(importData.circles)) {
                    layers.circles = importData.circles;
                }

                // Import line segments
                if (importData.lineSegments && Array.isArray(importData.lineSegments)) {
                    layers.lineSegments = importData.lineSegments;
                }

                // Import points
                if (importData.points && Array.isArray(importData.points)) {
                    layers.points = importData.points;
                }

                // Import saved coordinates
                if (importData.savedCoordinates && Array.isArray(importData.savedCoordinates)) {
                    savedCoordinates = importData.savedCoordinates;
                    localStorage.setItem('gpxCircle_savedCoordinates', JSON.stringify(savedCoordinates));
                }

                // Refresh UI
                updateLayersPanel();
                updateMapPreview();
                alert('Data imported successfully!');
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing data: ' + error.message);
            }
        };
        reader.readAsText(file);
    }

    // Update filename display
    function updateFilenameDisplay() {
        const filenameInput = document.getElementById('filename');
        if (filenameManuallyEdited) {
            return; // Don't override if user has edited it
        }

        const suggested = generateSuggestedFilename();
        if (suggested) {
            filenameInput.placeholder = `Suggested: ${suggested}`;
        }
    }

    // Show inline error message
    function showInlineError(elementId, message) {
        const errorEl = document.getElementById(elementId);
        if (errorEl) {
            if (message) {
                errorEl.textContent = message;
                errorEl.classList.add('show');
            } else {
                errorEl.classList.remove('show');
                errorEl.textContent = '';
            }
        }
    }

    // Update map in real-time as inputs change
    function updateMapPreview() {
        if (!mapInitialized || !map) {
            return;
        }

        // Clear all map layers
        mapLayers.forEach(layer => {
            map.removeLayer(layer);
        });
        mapLayers = [];

        try {
            // Draw all circles from layers
            if (layers.circles.length > 0) {
                const colors = ['#0066cc', '#8b5cf6', '#10b981', '#f59e0b', '#ef4444', '#ec4899'];
                layers.circles.forEach((circle, index) => {
                    const color = colors[index % colors.length];

                    // Add center marker
                    const centerMarker = L.circleMarker([circle.center.lat, circle.center.lon], {
                        radius: 6,
                        fillColor: color,
                        color: color,
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                    }).addTo(map);
                    centerMarker.bindPopup(
                        `<b>${escapeHtml(circle.name)}</b><br>Center: ${circle.center.lat.toFixed(6)}, ${circle.center.lon.toFixed(6)}<br>Radius: ${circle.radius} km`
                    );
                    mapLayers.push(centerMarker);

                    // Add circle
                    const mapCircle = L.circle([circle.center.lat, circle.center.lon], {
                        color: color,
                        fillColor: color,
                        fillOpacity: 0.2,
                        radius: circle.radius * 1000, // Convert km to meters
                        weight: 3,
                    }).addTo(map);
                    mapCircle.bindPopup(
                        `<b>${escapeHtml(circle.name)}</b><br>Radius: ${circle.radius} km`
                    );
                    mapLayers.push(mapCircle);
                });
            }

            // Draw all line segments from layers
            if (layers.lineSegments.length > 0) {
                layers.lineSegments.forEach((segment, index) => {
                    let endpoint;

                    if (segment.mode === 'coordinate') {
                        endpoint = segment.endpoint;
                    } else if (segment.mode === 'azimuth') {
                        // Calculate endpoint from azimuth and distance
                        endpoint = destinationPoint(
                            segment.center.lat,
                            segment.center.lon,
                            segment.distance,
                            segment.azimuth
                        );
                    } else if (segment.mode === 'intersection') {
                        // Endpoint is already calculated and stored
                        endpoint = segment.endpoint;
                    }

                    const color = '#000000'; // Always use black for line segments

                    // Draw line as simple 2-point straight line (matches GPX output)
                    const polylineLatLngs = [
                        [segment.center.lat, segment.center.lon],
                        [endpoint.lat, endpoint.lon]
                    ];
                    const polyline = L.polyline(
                        polylineLatLngs,
                        {
                            color: color,
                            weight: 3,
                            opacity: 0.8,
                            dashArray: '5, 5',
                        }
                    ).addTo(map);
                    polyline.bindPopup(
                        `<b>${escapeHtml(segment.name)}</b><br>From: ${segment.center.lat.toFixed(4)}, ${segment.center.lon.toFixed(4)}<br>To: ${endpoint.lat.toFixed(4)}, ${endpoint.lon.toFixed(4)}`
                    );
                    mapLayers.push(polyline);

                    // For intersection mode, also show the intersection point visually
                    if (segment.mode === 'intersection' && segment.intersectionPoint) {
                        const intersectionMarker = L.circleMarker([segment.intersectionPoint.lat, segment.intersectionPoint.lon], {
                            radius: 8,
                            fillColor: '#FFD700', // Gold color for intersection point
                            color: '#FFA500',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.9,
                        }).addTo(map);
                        intersectionMarker.bindPopup(
                            `<b>${escapeHtml(segment.name)} - Intersection Point</b><br>Lat: ${segment.intersectionPoint.lat.toFixed(6)}<br>Lon: ${segment.intersectionPoint.lon.toFixed(6)}`
                        );
                        mapLayers.push(intersectionMarker);
                    }

                    // Draw start point
                    const startMarker = L.marker([segment.center.lat, segment.center.lon], {
                        title: escapeHtml(segment.name) + ' Start',
                    }).addTo(map);
                    startMarker.bindPopup(
                        `<b>${escapeHtml(segment.name)} - Start</b><br>Lat: ${segment.center.lat.toFixed(6)}<br>Lon: ${segment.center.lon.toFixed(6)}`
                    );
                    mapLayers.push(startMarker);

                    // Draw end point
                    const endMarker = L.circleMarker([endpoint.lat, endpoint.lon], {
                        radius: 6,
                        fillColor: color,
                        color: color,
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8,
                    }).addTo(map);
                    endMarker.bindPopup(
                        `<b>${escapeHtml(segment.name)} - End</b><br>Lat: ${endpoint.lat.toFixed(6)}<br>Lon: ${endpoint.lon.toFixed(6)}`
                    );
                    mapLayers.push(endMarker);
                });
            }

            // Draw all points from layers
            if (layers.points.length > 0) {
                layers.points.forEach((point) => {
                    const pointMarker = L.marker([point.coordinates.lat, point.coordinates.lon], {
                        title: point.name,
                    }).addTo(map);
                    pointMarker.bindPopup(
                        `<b>${escapeHtml(point.name)}</b><br>Lat: ${point.coordinates.lat.toFixed(6)}<br>Lon: ${point.coordinates.lon.toFixed(6)}`
                    );
                    mapLayers.push(pointMarker);
                });
            }

            // Fit map to show all elements
            if (mapLayers.length > 0) {
                const group = new L.featureGroup(mapLayers);
                map.fitBounds(group.getBounds(), {
                    padding: [50, 50],
                    animate: true,
                    duration: 1,
                });
            }
        } catch (mapError) {
            console.error('Map update error:', mapError);
        }

        // Update filename suggestion
        updateFilenameDisplay();
    }

    // Add event listeners for real-time map updates (if hidden inputs exist)
    const coordsInput = document.getElementById('coordinates');
    if (coordsInput) {
        coordsInput.addEventListener('input', updateMapPreview);
        coordsInput.addEventListener('change', updateMapPreview);
    }

    const radiusInput = document.getElementById('radius');
    if (radiusInput) {
        radiusInput.addEventListener('input', updateMapPreview);
        radiusInput.addEventListener('change', updateMapPreview);
    }

    // Form submission handler
    // Store GPX data for download
    let pendingGPXData = {
        content: null,
        defaultFilename: null,
        circlesCount: 0,
        segmentsCount: 0,
        radii: [],
        points: 0
    };

    // Generate filename for GPX
    function generateGPXFilename() {
        const timestamp = getTimestamp();
        const radiiStr = pendingGPXData.radii.length === 1
            ? `${pendingGPXData.radii[0]}km`
            : `${pendingGPXData.radii.join('_')}km`;
        const circlesCount = pendingGPXData.circlesCount;
        const segmentsCount = pendingGPXData.segmentsCount;
        return segmentsCount > 0
            ? `${timestamp}_${circlesCount}circles_${segmentsCount}segments_${radiiStr}.gpx`
            : `${timestamp}_${circlesCount}circles_${radiiStr}.gpx`;
    }

    document.getElementById('gpxForm').addEventListener('submit', function (e) {
        e.preventDefault();

        // Check if there are any elements added
        if (layers.circles.length === 0 && layers.lineSegments.length === 0 && layers.points.length === 0) {
            showMessage('Please add at least one element (circle, line segment, or point)', true);
            return;
        }

        try {
            // Convert layers to centers and radii arrays for GPX generation
            const centers = layers.circles.map(c => c.center);
            const radii = layers.circles.map(c => c.radius);

            // Fixed number of points
            const points = 360;

            // Convert line segments to the format expected by generateCompleteGPX
            const lineSegments = layers.lineSegments.map(segment => ({
                center: segment.center,
                mode: segment.mode,
                endpoint: segment.mode === 'coordinate' || segment.mode === 'intersection' ? segment.endpoint : null,
                azimuth: segment.mode === 'azimuth' ? segment.azimuth : null,
                distance: segment.mode === 'azimuth' ? segment.distance : null,
                intersectionPoint: segment.mode === 'intersection' ? segment.intersectionPoint : null,
                intersectionDistance: segment.mode === 'intersection' ? segment.intersectionDistance : null
            }));

            // Update map preview
            updateMapPreview();

            // Generate GPX with circles, line segments, and points
            const gpxContent = generateCompleteGPX(centers, radii, points, lineSegments, layers.points);

            // Store GPX data for download
            pendingGPXData.content = gpxContent;
            pendingGPXData.circlesCount = layers.circles.length;
            pendingGPXData.segmentsCount = layers.lineSegments.length;
            pendingGPXData.pointsCount = layers.points.length;
            pendingGPXData.radii = radii;
            pendingGPXData.points = points;
            pendingGPXData.defaultFilename = generateGPXFilename();

            // Show filename modal with prefilled filename
            document.getElementById('filenameInput').value = pendingGPXData.defaultFilename.replace('.gpx', '');
            document.getElementById('filenameModalTitle').textContent = 'Download GPX File';
            document.getElementById('confirmFilenameBtn').textContent = 'Download';
            document.getElementById('filenameForm').dataset.action = 'download';
            openModal('filenameModal');
        } catch (error) {
            showMessage('Error generating GPX file: ' + error.message, true);
        }
    });

    // Allow GPX form submission by pressing Enter
    const gpxForm = document.getElementById('gpxForm');
    if (gpxForm) {
        gpxForm.addEventListener('keydown', function (e) {
            if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                gpxForm.dispatchEvent(new Event('submit'));
            }
        });
    }

    // ===== PROJECT MANAGEMENT: SAVE/LOAD/DELETE =====
    // Old function to support backward compatibility (kept for reference)
    function collectLegacyLineSegments() {
        const lineSegments = [];
        const container = document.getElementById('lineSegmentsContainer');
        const segmentItems = container.querySelectorAll('.line-segment-item');

        segmentItems.forEach((item, index) => {
            const centerInput = item.querySelector('.segment-center').value.trim();
            const mode = item.querySelector('input[name="segment-mode-' + index + '"]:checked')?.value || 'coordinate';
            const endpointInput = item.querySelector('.segment-endpoint')?.value.trim() || '';
            const azimuthInput = item.querySelector('.segment-azimuth')?.value || '';
            const distanceInput = item.querySelector('.segment-distance')?.value || '';

            if (centerInput) {
                lineSegments.push({
                    center: centerInput,
                    mode: mode,
                    endpoint: endpointInput,
                    azimuth: azimuthInput,
                    distance: distanceInput
                });
            }
        });

        return lineSegments;
    }

    // Save project with a name
    function saveProject(projectName) {
        if (!projectName || projectName.trim().length === 0) {
            showMessage('Please enter a project name', true);
            return false;
        }

        const projects = getAllProjects();
        const formData = getCurrentFormData();

        // Check if project name already exists
        const existingIndex = projects.findIndex(p => p.name.toLowerCase() === projectName.toLowerCase());

        if (existingIndex >= 0) {
            // Ask for confirmation or just replace
            if (confirm(`Project "${projectName}" already exists. Do you want to overwrite it?`)) {
                projects[existingIndex] = {
                    name: projectName,
                    data: formData,
                    timestamp: new Date().toISOString()
                };
            } else {
                return false;
            }
        } else {
            projects.push({
                name: projectName,
                data: formData,
                timestamp: new Date().toISOString()
            });
        }

        // Sort projects by name
        projects.sort((a, b) => a.name.localeCompare(b.name));
        saveProjectsToStorage(projects);

        // Show feedback
        showMessage(`Project "${projectName}" saved successfully!`, false);
        showToast(`‚ú® Project "${projectName}" saved!`, true, 2500);
        refreshProjectsDropdown();

        return true;
    }

    // Delete project
    function deleteProject(projectName, event) {
        event.stopPropagation();

        if (confirm(`Are you sure you want to delete "${projectName}"?`)) {
            let projects = getAllProjects();
            projects = projects.filter(p => p.name !== projectName);
            saveProjectsToStorage(projects);
            refreshProjectsDropdown();
            showMessage(`Project "${projectName}" deleted.`, false);
            showToast(`üóëÔ∏è Project "${projectName}" deleted.`, true, 2000);
        }
    }

    // Refresh the projects dropdown
    function refreshProjectsDropdown() {
        const projects = getAllProjects();
        const dropdown = document.getElementById('projectDropdown');
        dropdown.innerHTML = '';

        if (projects.length === 0) {
            dropdown.innerHTML = '<div style="padding: 12px 16px; color: #94a3b8; font-size: 14px;">No saved projects yet</div>';
            return;
        }

        projects.forEach(project => {
            const item = document.createElement('div');
            item.className = 'project-item';
            item.innerHTML = `
            <span class="project-item-name">${escapeHtml(project.name)}</span>
            <span class="project-item-delete" onclick="deleteProject('${escapeHtml(project.name)}', event)">√ó</span>
          `;
            item.addEventListener('click', function (e) {
                if (e.target.className === 'project-item-delete') return;
                loadFormData(project.data);
                document.getElementById('projectSearch').value = '';
                dropdown.classList.remove('show');
            });
            dropdown.appendChild(item);
        });
    }

    // Filter projects by search term
    function filterProjects(searchTerm) {
        const projects = getAllProjects();
        const dropdown = document.getElementById('projectDropdown');
        dropdown.innerHTML = '';

        const filtered = projects.filter(p =>
            p.name.toLowerCase().includes(searchTerm.toLowerCase())
        );

        if (filtered.length === 0) {
            dropdown.innerHTML = '<div style="padding: 12px 16px; color: #94a3b8; font-size: 14px;">No projects match your search</div>';
            return;
        }

        filtered.forEach(project => {
            const item = document.createElement('div');
            item.className = 'project-item';
            item.innerHTML = `
            <span class="project-item-name">${escapeHtml(project.name)}</span>
            <span class="project-item-delete" onclick="deleteProject('${escapeHtml(project.name)}', event)">√ó</span>
          `;
            item.addEventListener('click', function (e) {
                if (e.target.className === 'project-item-delete') return;
                loadFormData(project.data);
                document.getElementById('projectSearch').value = '';
                dropdown.classList.remove('show');
            });
            dropdown.appendChild(item);
        });
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    // ===== INITIALIZATION =====
    // Initialize saved coordinates on page load
    document.addEventListener('DOMContentLoaded', function () {
        loadSavedCoordinates();
        renderSavedCoordinates();
    });

    // Also initialize immediately in case DOMContentLoaded has already fired
    loadSavedCoordinates();
    renderSavedCoordinates();

    // Generate great-circle points from start that pass through a given intersection point
    // Returns numPoints+1 points from start to totalDistanceKm along the great-circle
    function generateLinePointsThroughIntersection(startLat, startLon, intersectLat, intersectLon, totalDistanceKm, numPoints) {
        const R = 6371; // km
        const points = [];

        const startVec = latLonToVector(startLat, startLon);
        const interVec = latLonToVector(intersectLat, intersectLon);

        // Great-circle normal axis
        let axis = crossProduct(startVec, interVec);
        const axisMag = magnitude(axis);
        if (axisMag < 1e-12) {
            // Degenerate: fallback to simple interpolation to destination
            const bearing = calculateBearing(startLat, startLon, intersectLat, intersectLon);
            const end = destinationPoint(startLat, startLon, totalDistanceKm, bearing);
            return generateLinePoints(startLat, startLon, end.lat, end.lon, numPoints);
        }
        axis = normalize(axis);

        // Ensure positive rotation goes from start toward intersection
        const angleToInter = Math.acos(Math.max(-1, Math.min(1, dotProduct(startVec, interVec))));
        const testVec = rotateVector(startVec, axis, angleToInter);
        if (dotProduct(testVec, interVec) <= 0.999999) {
            axis = {x: -axis.x, y: -axis.y, z: -axis.z};
        }

        const totalAngle = totalDistanceKm / R; // radians
        for (let i = 0; i <= numPoints; i++) {
            const angle = (totalAngle * i) / numPoints;
            const v = rotateVector(startVec, axis, angle);
            const p = vectorToLatLon(normalize(v));
            points.push(p);
        }

        return points;
    }

</script>
<!-- Inlined sidebar/map bootstrapper (previously in script.js) -->
<script>
    // GPX Drawing Tool ‚Äî Sidebar + Fullscreen Map bootstrapper
    // This small script keeps the legacy logic intact and only rearranges the DOM
    // to match the new design (fullscreen map with a collapsible left sidebar).

    (function () {
        function moveLegacyUIIntoSidebar() {
            const sidebar = document.getElementById('sidebar');
            if (!sidebar) return;

            const projectMount = document.getElementById('projectMount');
            const formMount = document.getElementById('formMount');
            const statusMount = document.getElementById('statusMount');
            const actionsFooter = document.getElementById('actionsFooter');

            const container = document.querySelector('.container');
            const legacyMap = document.getElementById('map');
            const legacyForm = document.getElementById('gpxForm');
            const projectSelector = container ? container.querySelector('.project-selector') : null;
            const outputPanel = document.getElementById('output');

            // Move map to the document root so CSS can make it fullscreen
            if (legacyMap && legacyMap.parentElement !== document.body) {
                document.body.appendChild(legacyMap);
            }

            // Move project selector into the sidebar
            if (projectMount && projectSelector) {
                projectMount.appendChild(projectSelector);
            }

            // Move the whole form (includes buttons and layers panel)
            if (formMount && legacyForm) {
                formMount.appendChild(legacyForm);
            }

            // Move status/output panel
            if (statusMount && outputPanel) {
                statusMount.appendChild(outputPanel);
            }

            // Move action buttons (.button-group) into the sticky footer and wire submit
            const buttonGroup = legacyForm ? legacyForm.querySelector('.button-group') : null;
            if (actionsFooter && buttonGroup) {
                actionsFooter.appendChild(buttonGroup);
                const dlBtn = actionsFooter.querySelector('.btn-generate');
                if (dlBtn) {
                    dlBtn.addEventListener('click', function (e) {
                        e.preventDefault();
                        const form = document.getElementById('gpxForm');
                        if (form) {
                            if (typeof form.requestSubmit === 'function') form.requestSubmit();
                            else form.submit();
                        }
                    });
                }
            }

            // Hide leftover legacy container to avoid duplicate UI
            if (container) {
                container.style.display = 'none';
                document.body.classList.add('sidebar-ready');
            }
        }

        function setupSidebarToggle() {
            const toggleBtn = document.getElementById('sidebarToggle');
            const sidebar = document.getElementById('sidebar');
            if (!toggleBtn || !sidebar) return;

            const toggle = () => {
                const willOpen = !sidebar.classList.contains('open');
                sidebar.classList.toggle('open');

                // Update arrow direction
                toggleBtn.textContent = willOpen ? '‚Üê' : '‚Üí';
                toggleBtn.setAttribute('aria-pressed', String(willOpen));

                // Let the slide animation finish, then notify Leaflet about size changes
                setTimeout(() => {
                    try {
                        if (window.map && typeof window.map.invalidateSize === 'function') {
                            window.map.invalidateSize();
                        }
                    } catch (_) { /* ignore */
                    }
                }, 320);
            };

            toggleBtn.addEventListener('click', toggle);
        }

        // Initialize when DOM is ready. This script is loaded with defer, so DOM is parsed.
        document.addEventListener('DOMContentLoaded', function () {
            moveLegacyUIIntoSidebar();
            setupSidebarToggle();
        });
    })();
</script>
</body>
</html>

